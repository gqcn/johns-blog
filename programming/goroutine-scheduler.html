<!doctype html><html lang=en dir=ltr class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-docs/开发语言/Golang/Goroutine调度器" data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.6.3"><title data-rh=true>Goroutine调度器 | John's Blog</title><meta data-rh=true name=viewport content="width=device-width,initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:url content=https://johng.cn/programming/goroutine-scheduler><meta data-rh=true property=og:locale content=en><meta data-rh=true name=docusaurus_locale content=en><meta data-rh=true name=docsearch:language content=en><meta data-rh=true name=docusaurus_version content=current><meta data-rh=true name=docusaurus_tag content=docs-default-current><meta data-rh=true name=docsearch:version content=current><meta data-rh=true name=docsearch:docusaurus_tag content=docs-default-current><meta data-rh=true property=og:title content="Goroutine调度器 | John's Blog"><meta data-rh=true name=description content="深入解析 Go 语言的 Goroutine 调度器原理，包括 GMP 模型、调度策略、上下文切换等核心机制"><meta data-rh=true property=og:description content="深入解析 Go 语言的 Goroutine 调度器原理，包括 GMP 模型、调度策略、上下文切换等核心机制"><meta data-rh=true name=keywords content=Goroutine,调度器,GMP模型,并发编程,线程调度,Go运行时><link data-rh=true rel=icon href=/img/favicon.ico><link data-rh=true rel=canonical href=https://johng.cn/programming/goroutine-scheduler><link data-rh=true rel=alternate href=https://johng.cn/programming/goroutine-scheduler hreflang=en><link data-rh=true rel=alternate href=https://johng.cn/programming/goroutine-scheduler hreflang=x-default><link data-rh=true rel=preconnect href=https://XGS1CPQERK-dsn.algolia.net crossorigin><link rel=search type=application/opensearchdescription+xml title="John's Blog" href=/opensearch.xml><script src=https://hm.baidu.com/hm.js?6b4ae23dc83ee5efe875b7172af6c7c1 async></script><script src=https://cdn.wwads.cn/js/makemoney.js async></script><link rel=stylesheet href=/assets/css/styles.208c11f9.css><script src=/assets/js/runtime~main.7b8ccf99.js defer></script><script src=/assets/js/main.3d68a070.js defer></script><body class=navigation-with-keyboard><script>!function(){var t,e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t=null!==e?e:"light",document.documentElement.setAttribute("data-theme",t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><div role=region aria-label="Skip to main content"><a class=skipToContent_fXgn href=#__docusaurus_skipToContent_fallback>Skip to main content</a></div><nav aria-label=Main class="navbar navbar--fixed-top"><div class=navbar__inner><div class=navbar__items><button aria-label="Toggle navigation bar" aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/><b class="navbar__title text--truncate">John's Blog</b></a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/ai>AI技术</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/cloud-native>云原生</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/notes>日常笔记</a><a aria-current=page class="navbar__item navbar__link navbar__link--active" sidebarid=mainSidebar href=/programming>开发语言</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/architecture>技术架构</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/observability>可观测性</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/database-and-middleware>数据库与中间件</a><a class="navbar__item navbar__link" href=/aboutme>关于我</a></div><div class="navbar__items navbar__items--right"><a href=https://goframe.org/ target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-goframe-link"></a><a href=https://github.com/gqcn target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class=navbarSearchContainer_Bca1><button type=button class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 20 20" aria-hidden=true><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke=currentColor fill=none fill-rule=evenodd stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>Search</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="main-wrapper mainWrapper_z2l0"><div class=docsWrapper_hBAB><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type=button></button><div class=docRoot_UBD9><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class=sidebarViewport_aRkj><div class=sidebar_njMd><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/ai>AI技术</a><button aria-label="Expand sidebar category 'AI技术'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/cloud-native>云原生</a><button aria-label="Expand sidebar category '云原生'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/notes>日常笔记</a><button aria-label="Expand sidebar category '日常笔记'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist menu__link--active" href=/programming>开发语言</a><button aria-label="Collapse sidebar category '开发语言'" aria-expanded=true type=button class="clean-btn menu__caret"></button></div><ul style=display:block;overflow:visible;height:auto class=menu__list><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist menu__link--active" tabindex=0 href=/programming/golang>Golang</a><button aria-label="Collapse sidebar category 'Golang'" aria-expanded=true type=button class="clean-btn menu__caret"></button></div><ul style=display:block;overflow:visible;height:auto class=menu__list><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current=page tabindex=0 href=/programming/goroutine-scheduler>Goroutine调度器</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/golang-mutex-principle>Golang Mutex 原理解析</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/golang-knowledge-review>Golang知识点回顾梳理</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/golang-development-tips>Golang开发中的一些技巧</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/goland-json-tag-camelcase>Goland设置json标签自动生成格式为驼峰</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/go-test-disable-cache>go test 禁用缓存</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/golang-regex-rules>Golang正则规则</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/golang-kubernetes-resource-control>Golang程序在Kubernetes下的资源控制</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/golang-sigsegv-error>unexpected fault address 0x0 fatal error: fault signal SIGSEGV: segmentation violation</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/godebug-gc-trace>GODEBUG配置GC跟踪介绍</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/golang-memory-optimization-case>一个Golang程序内存占用问题排查优化（复盘）</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/programming/goland-remote-debug>使用goland remote debug远程调试</a></ul></ul><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/architecture>技术架构</a><button aria-label="Expand sidebar category '技术架构'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/management>技术管理</a><button aria-label="Expand sidebar category '技术管理'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/observability>可观测性</a><button aria-label="Expand sidebar category '可观测性'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/database-and-middleware>数据库与中间件</a><button aria-label="Expand sidebar category '数据库与中间件'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/operating-systems-and-networks>操作系统和网络</a><button aria-label="Expand sidebar category '操作系统和网络'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div></ul></nav></div></div></aside><main class=docMainContainer_TBSr><div class="container padding-top--md padding-bottom--lg"><div class=row><div class="col docItemCol_VOVn"><div class=docItemContainer_Djhp><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label=Breadcrumbs><ul class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li class=breadcrumbs__item><a aria-label="Home page" class=breadcrumbs__link href=/><svg viewBox="0 0 24 24" class=breadcrumbHomeIcon_YNFT><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill=currentColor /></svg></a><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class=breadcrumbs__item><a class=breadcrumbs__link itemprop=item href=/programming><span itemprop=name>开发语言</span></a><meta itemprop=position content=1><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class=breadcrumbs__item><a class=breadcrumbs__link itemprop=item href=/programming/golang><span itemprop=name>Golang</span></a><meta itemprop=position content=2><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class="breadcrumbs__item breadcrumbs__item--active"><span class=breadcrumbs__link itemprop=name>Goroutine调度器</span><meta itemprop=position content=3></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type=button class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h2 class="anchor anchorWithStickyNavbar_LWe7" id=一pmg关系>一、P、M、G关系<a href=#一pmg关系 class=hash-link aria-label="Direct link to 一、P、M、G关系" title="Direct link to 一、P、M、G关系">​</a></h2>
<p>在了解Go的运行时的<code>scheduler</code>之前，需要先了解为什么需要它，因为我们可能会想，OS内核不是已经有一个线程<code>scheduler</code>了嘛？<br>
<!-- -->熟悉<code>POSIX API</code>的人都知道，<code>POSIX</code>的方案在很大程度上是对<code>Unix process</code>进程模型的一个逻辑描述和扩展，两者有很多相似的地方。 <code>Thread</code>有自己的信号掩码、<code>CPU affinity</code>等。但是很多特征对于<code>Go</code>程序来说都是累赘。 尤其是<code>context</code>上下文切换的耗时。另一个原因是<code>Go</code>的垃圾回收需要所有的<code>goroutine</code>停止，使得内存在一个一致的状态。垃圾回收的时间点是不确定的，如果依靠<code>OS</code>自身的<code>scheduler</code>来调度，那么会有大量的线程需要停止工作。</p>
<p>单独的开发一个<code>Go</code>的调度器，可以是其知道在什么时候内存状态是一致的，也就是说，当开始垃圾回收时，运行时只需要为当时正在<code>CPU</code>核上运行的那个线程等待即可，而不是等待所有的线程。</p>
<p>用户空间线程和内核空间线程之间的映射关系有：<code>N:1</code>、<code>1:1</code>和<code>M:N</code><br>
<code>N:1</code>是说，多个（N）用户线程始终在一个内核线程上跑，<code>context</code>上下文切换确实很快，但是无法真正的利用多核。<br>
<code>1:1</code>是说，一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢。<br>
<code>M:N</code>是说， 多个<code>goroutine</code>在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。</p>
<p><img decoding=async loading=lazy src="data:image/jpeg;base64,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" width=391 height=103 class=img_ev3q></p>
<p><code>Go</code>的调度器内部有三个重要的结构：<strong>M，P，G</strong><br>
<strong>M</strong>：代表真正的内核<code>OS</code>线程，和<code>POSIX</code>里的<code>thread</code>差不多，真正干活的人<br>
<strong>G</strong>：代表一个<code>goroutine</code>，它有自己的栈，<code>instruction pointer</code>和其他信息（正在等待的<code>channel</code>等等），用于调度。<br>
<strong>P</strong>：代表调度的上下文，可以把它看做一个<strong>局部的调度器</strong>，使<code>go</code>代码在一个线程上跑，它是实现从<code>N:1</code>到<code>N:M</code>映射的关键。</p>
<p><img decoding=async loading=lazy src=/assets/images/auto-67f09d490f69eec14c1824d939938e14_hd-5f754a5e3f640e989ec206a63ce5dee2.jpeg width=400 height=391 class=img_ev3q></p>
<p>图中看，有2个物理线程<strong>M</strong>，每一个M都拥有一个<code>context（P）</code>，每一个也都有一个正在运行的<code>goroutine</code>。<strong>P</strong>的数量可以通过<code>runtime.GOMAXPROCS()</code>来设置，它其实也就代表了真正的并发度，即有多少个<code>goroutine</code>可以同时运行。图中灰色的那些<code>goroutine</code>并没有运行，而是处于<code>ready</code>的就绪态，正在等待被调度。<strong>P</strong>维护着这个队列（称之为<code>runqueue</code>），<code>Go</code>语言里，启动一个<code>goroutine</code>很容易：<code>go function</code> 就行，所以每有一个<code>go</code>语句被执行，<code>runqueue</code>队列就在其末尾加入一个<code>goroutine</code>，在下一个调度点，就从<code>runqueue</code>中取出（如何决定取哪个<code>goroutine</code>？）一个<code>goroutine</code>执行。</p>
<p>为何要维护多个上下文<strong>P</strong>？因为当一个OS线程被阻塞时，<strong>P</strong>可以转而投奔另一个OS线程！<br>
<!-- -->图中看到，<strong>当一个OS线程M0陷入阻塞时，P转而在OS线程M1上运行</strong>。调度器保证有足够的线程来运行所有的<code>context P</code>。</p>
<p><img decoding=async loading=lazy src=/assets/images/auto-f1125f3027ebb2bd5183cf8c9ce4b3f2_hd-3bcd301c7e0bb37510631439166afd4a.jpeg width=550 height=400 class=img_ev3q></p>
<p>图中的<strong>M1</strong>可能是被创建，或者从线程缓存中取出。当<strong>M0</strong>返回时，它必须尝试取得一个<code>context P</code>来运行<code>goroutine</code>，一般情况下，它会从其他的<code>OS</code>线程那里<code>steal</code>偷一个<code>context</code>过来，<br>
<!-- -->如果没有偷到的话，它就把<code>goroutine</code>放在一个<code>global runqueue</code>里，然后自己就去睡大觉了（放入线程缓存里）。<code>Contexts</code>们也会周期性的检查<code>global runqueue</code>，否则<code>global runqueue</code>上的<code>goroutine</code>永远无法执行。</p>
<p><img decoding=async loading=lazy src=/assets/images/auto-31f04bb69d72b72777568063742741cd_hd-527d713d8f064ded161ee1eb90128065.jpeg width=550 height=400 class=img_ev3q></p>
<p>另一种情况是<strong>P</strong>所分配的任务<strong>G</strong>很快就执行完了（分配不均），这就导致了一个上下文<strong>P</strong>闲着没事儿干而系统却任然忙碌。但是如果<code>global runqueue</code>没有任务<strong>G</strong>了，那么<strong>P</strong>就不得不从其他的上下文<strong>P</strong>那里拿一些<strong>G</strong>来执行。一般来说，如果上下文<strong>P</strong>从其他的上下文<strong>P</strong>那里要偷一个任务的话，一般就"偷"<code>runqueue</code>的<strong>一半</strong>，这就确保了每个<code>OS</code>线程都能充分的使用。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=二调度流程简述>二、调度流程简述<a href=#二调度流程简述 class=hash-link aria-label="Direct link to 二、调度流程简述" title="Direct link to 二、调度流程简述">​</a></h2>
<p>我们都知道<code>Go</code>语言是原生支持语言级并发的，这个并发的最小逻辑单元就是<code>goroutine</code>。<code>goroutine</code>就类似于<code>Go</code>语言提供的一种“<strong>用户态线程</strong>”，当然这种“用户态线程”是跑在<strong>内核级线程</strong>之上的。当我们创建了很多的<code>goroutine</code>，并且它们都是跑在同一个内核线程之上的时候，就需要一个调度器来维护这些<code>goroutine</code>，确保所有的<code>goroutine</code>都使用<code>CPU</code>，并且是尽可能公平的使用<code>CPU</code>资源。</p>
<p>这个调度器的原理以及实现值得我们去深入研究一下。支撑整个调度器的主要有<strong>4</strong>个重要结构，分别是<strong>P、M、G、Sched</strong>，前三个定义在<code>runtime.h</code>中，<strong>Sched</strong>定义在<code>proc.c</code>中。</p>
<ul>
<li><strong>Sched</strong>结构就是调度器，它维护有存储<strong>M</strong>和<strong>G</strong>的队列以及调度器的一些状态信息等。</li>
<li><strong>M</strong>代表<strong>内核级线程</strong>，一个M就是一个线程，<code>goroutine</code>就是跑在M之上的；M是一个很大的结构，里面维护小对象内存<code>cache(mcache)</code>、当前执行的<code>goroutine</code>、随机数发生器等等非常多的信息。</li>
<li><strong>P</strong>全称是<code>Processor</code>，<strong>处理器</strong>，它的主要用途就是用来执行<code>goroutine</code>的，所以它也维护了一个<code>goroutine</code>队列，里面存储了所有需要它来执行的<code>goroutine</code>，这个<strong>P</strong>的角色可能有一点让人迷惑，一开始容易和<strong>M</strong>冲突，后面重点聊一下它们的关系。</li>
<li><strong>G</strong>就是<code>goroutine</code>实现的核心结构了，<strong>G</strong>维护了<code>goroutine</code>需要的栈、程序计数器以及它所在的<strong>M</strong>等信息。</li>
</ul>
<p>理解<strong>M、P、G</strong>三者的关系对理解整个调度器非常重要，我从网络上找了一个图来说明其三者关系：</p>
<p><img decoding=async loading=lazy src=/assets/images/auto-gopher-bz-b18b91ced1de1df56a54e97cc27a4992.jpeg width=800 height=267 class=img_ev3q></p>
<p>地鼠用小车运着一堆待加工的砖。<strong>M</strong>就可以看作图中的地鼠，<strong>P</strong>就是小车，<strong>G</strong>就是小车里装的砖。一图胜千言啊，弄清楚了它们三者的关系，下面我们就开始重点聊地鼠是如何在搬运砖块的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=启动过程>启动过程<a href=#启动过程 class=hash-link aria-label="Direct link to 启动过程" title="Direct link to 启动过程">​</a></h3>
<p>在关心绝大多数程序的内部原理的时候，我们都试图去弄明白其启动初始化过程，弄明白这个过程对后续的深入分析至关重要。在<code>asm_amd64.s</code>文件中的汇编代码<code>_rt0_amd64</code>就是整个启动过程，核心过程如下：</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style=--prism-color:#f8f8f2;--prism-background-color:#272822><div class=codeBlockContent_biex><pre tabindex=0 class="prism-code language-text codeBlock_bY9V thin-scrollbar" style=color:#f8f8f2;background-color:#272822><code class=codeBlockLines_e6Vv><span class=token-line style=color:#f8f8f2><span class="token plain">CALL    runtime.args(SB)</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">CALL    runtime.osinit(SB)</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">CALL    runtime.hashinit(SB)</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">CALL    runtime.schedinit(SB)</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain"> </span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">// create a new goroutine to start program</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">PUSHQ    $runtime.main.f(SB)        // entry</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">PUSHQ    $0            // arg size</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">CALL    runtime.newproc(SB)</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">POPQ    AX</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">POPQ    AX</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain"> </span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">// start this M</span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">CALL    runtime.mstart(SB)</span><br></span></code></pre><div class=buttonGroup__atx><button type=button aria-label="Copy code to clipboard" title=Copy class=clean-btn><span class=copyButtonIcons_eSgA aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_y97N><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_LjdS><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>启动过程做了调度器初始化<code>runtime.schedinit</code>后，调用<code>runtime.newproc</code>创建出第一个<code>goroutine</code>，这个<code>goroutine</code>将执行的函数是<code>runtime.main</code>，这第一个<code>goroutine</code>也就是所谓的主<code>goroutine</code>。我们写的最简单的Go程序<code>hello，world</code>就是完全跑在这个<code>goroutine</code>里，当然任何一个Go程序的入口都是从这个<code>goroutine</code>开始的。最后调用的<code>runtime.mstart</code>就是真正的执行上一步创建的主<code>goroutine</code>。</p>
<p>启动过程中的调度器初始化<code>runtime.schedinit</code>函数主要根据用户设置的<code>GOMAXPROCS</code>值来创建一批小车(<strong>P</strong>)，不管<code>GOMAXPROCS</code>设置为多大，<strong>最多也只能创建256个小车(P)</strong>。这些小车(<strong>P</strong>)初始创建好后都是闲置状态，也就是还没开始使用，所以它们都放置在调度器结构(<strong>Sched</strong>)的<code>pidle</code>字段维护的链表中存储起来了，以备后续之需。</p>
<p>查看<code>runtime.main</code>函数可以了解到主<code>goroutine</code>开始执行后，做的第一件事情是创建了一个新的<strong>内核级线程</strong>(地鼠<strong>M</strong>)，不过这个线程是一个特殊线程，它在整个运行期专门负责做特定的事情——系统监控(<strong>sysmon</strong>)。接下来就是进入Go程序的<code>main</code>函数开始Go程序的执行。</p>
<p>至此，Go程序就被启动起来开始运行了。一个真正干活的Go程序，一定创建有不少的<code>goroutine</code>，所以在Go程序开始运行后，就会向调度器添加<code>goroutine</code>，调度器就要负责维护好这些<code>goroutine</code>的正常执行。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=创建goroutineg>创建goroutine(G)<a href=#创建goroutineg class=hash-link aria-label="Direct link to 创建goroutine(G)" title="Direct link to 创建goroutine(G)">​</a></h3>
<p>在Go程序中，时常会有类似代码：</p>
<div class="language-go codeBlockContainer_Ckt0 theme-code-block" style=--prism-color:#f8f8f2;--prism-background-color:#272822><div class=codeBlockContent_biex><pre tabindex=0 class="prism-code language-go codeBlock_bY9V thin-scrollbar" style=color:#f8f8f2;background-color:#272822><code class=codeBlockLines_e6Vv><span class=token-line style=color:#f8f8f2><span class="token keyword" style=color:#66d9ef>go</span><span class="token plain"> </span><span class="token function" style=color:#e6db74>do_something</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token punctuation" style=color:#f8f8f2>)</span><br></span></code></pre><div class=buttonGroup__atx><button type=button aria-label="Copy code to clipboard" title=Copy class=clean-btn><span class=copyButtonIcons_eSgA aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_y97N><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_LjdS><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>go关键字就是用来创建一个<code>goroutine</code>的，后面的函数就是这个<code>goroutine</code>需要执行的代码逻辑。go关键字对应到调度器的接口就是 <code>runtime.newproc</code>。<code>runtime.newproc</code>干的事情很简单，就负责制造一块砖(<strong>G</strong>)，然后将这块砖(<strong>G</strong>)放入当前这个地鼠(<strong>M</strong>)的小车(<strong>P</strong>)中。</p>
<p>每个新的<code>goroutine</code>都需要有一个自己的栈，<strong>G</strong>结构的<code>sched</code>字段维护了<strong>栈地址以及程序计数器等信息</strong>，这是最基本的调度信息，也就是说这个<code>goroutine</code>放弃<code>cpu</code>的时候需要保存这些信息，待下次重新获得<code>cpu</code>的时候，需要将这些信息装载到对应的<code>cpu</code>寄存器中。</p>
<p>假设这个时候已经创建了大量的<code>goroutne</code>，就轮到<strong>调度器</strong>去维护这些<code>goroutine</code>了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=创建内核线程m>创建内核线程(M)<a href=#创建内核线程m class=hash-link aria-label="Direct link to 创建内核线程(M)" title="Direct link to 创建内核线程(M)">​</a></h3>
<p>Go程序中没有语言级的关键字让你去创建一个内核线程，你只能创建<code>goroutine</code>，内核线程只能由<code>runtime</code>根据实际情况去创建。<code>runtime</code>什么时候创建线程？以地鼠运砖图来讲，砖(<strong>G</strong>)太多了，地鼠(<strong>M</strong>)又太少了，实在忙不过来，刚好还有空闲的小车(<strong>P</strong>)没有使用，那就从别处再借些地鼠(<strong>M</strong>)过来直到把小车(<strong>P</strong>)用完为止。这里有一个地鼠(<strong>M</strong>)不够用，从别处借地鼠(<strong>M</strong>)的过程，这个过程就是创建一个内核线程(<strong>M</strong>)。创建M的接口函数是:</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style=--prism-color:#f8f8f2;--prism-background-color:#272822><div class=codeBlockContent_biex><pre tabindex=0 class="prism-code language-c codeBlock_bY9V thin-scrollbar" style=color:#f8f8f2;background-color:#272822><code class=codeBlockLines_e6Vv><span class=token-line style=color:#f8f8f2><span class="token keyword" style=color:#66d9ef>void</span><span class="token plain"> </span><span class="token function" style=color:#e6db74>newm</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token keyword" style=color:#66d9ef>void</span><span class="token plain"> </span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token operator" style=color:#66d9ef>*</span><span class="token plain">fn</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token keyword" style=color:#66d9ef>void</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token punctuation" style=color:#f8f8f2>,</span><span class="token plain"> P </span><span class="token operator" style=color:#66d9ef>*</span><span class="token plain">p</span><span class="token punctuation" style=color:#f8f8f2>)</span><br></span></code></pre><div class=buttonGroup__atx><button type=button aria-label="Copy code to clipboard" title=Copy class=clean-btn><span class=copyButtonIcons_eSgA aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_y97N><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_LjdS><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p><code>newm</code>函数的核心行为就是调用<code>clone</code>系统调用创建一个内核线程，每个内核线程的开始执行位置都是<code>runtime.mstart</code>函数。参数<code>p</code>就是一辆空闲的小车(<strong>P</strong>)。每个创建好的内核线程都从<code>runtime.mstart</code>函数开始执行了，它们将用分配给自己小车去搬砖了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=调度核心>调度核心<a href=#调度核心 class=hash-link aria-label="Direct link to 调度核心" title="Direct link to 调度核心">​</a></h3>
<p><code>newm</code>接口只是给新创建的<strong>M</strong>分配了一个空闲的<strong>P</strong>，也就是相当于告诉借来的地鼠(<strong>M</strong>)——"接下来的日子，你将使用1号小车搬砖，记住是1号小车；待会自己到停车场拿车。"，地鼠(<strong>M</strong>)去拿小车(<strong>P</strong>)这个过程就是 <code>acquirep</code>。<code>runtime.mstart</code>在进入 <code>schedule</code>之前会给当前<strong>M</strong>装配上<strong>P</strong>，<code>runtime.mstart</code>函数中的代码：</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style=--prism-color:#f8f8f2;--prism-background-color:#272822><div class=codeBlockContent_biex><pre tabindex=0 class="prism-code language-c codeBlock_bY9V thin-scrollbar" style=color:#f8f8f2;background-color:#272822><code class=codeBlockLines_e6Vv><span class=token-line style=color:#f8f8f2><span class="token punctuation" style=color:#f8f8f2>}</span><span class="token plain"> </span><span class="token keyword" style=color:#66d9ef>else</span><span class="token plain"> </span><span class="token keyword" style=color:#66d9ef>if</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token plain">m </span><span class="token operator" style=color:#66d9ef>!=</span><span class="token plain"> </span><span class="token operator" style=color:#66d9ef>&</span><span class="token plain">runtime</span><span class="token punctuation" style=color:#f8f8f2>.</span><span class="token plain">m0</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token plain"> </span><span class="token punctuation" style=color:#f8f8f2>{</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">    </span><span class="token function" style=color:#e6db74>acquirep</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token plain">m</span><span class="token operator" style=color:#66d9ef>-></span><span class="token plain">nextp</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token punctuation" style=color:#f8f8f2>;</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">    m</span><span class="token operator" style=color:#66d9ef>-></span><span class="token plain">nextp </span><span class="token operator" style=color:#66d9ef>=</span><span class="token plain"> nil</span><span class="token punctuation" style=color:#f8f8f2>;</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain"></span><span class="token punctuation" style=color:#f8f8f2>}</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain"></span><span class="token function" style=color:#e6db74>schedule</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token punctuation" style=color:#f8f8f2>;</span><br></span></code></pre><div class=buttonGroup__atx><button type=button aria-label="Copy code to clipboard" title=Copy class=clean-btn><span class=copyButtonIcons_eSgA aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_y97N><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_LjdS><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p><code>if</code>分支的内容就是为当前<strong>M</strong>装配上<strong>P</strong>， <code>nextp</code>就是<code>newm</code>分配的空闲小车(<strong>P</strong>)，只是到这个时候才真正拿到手罢了。没有<strong>P、M</strong>是无法执行<code>goroutine</code>的，就像地鼠没有小车无法运砖一样的道理。对应<code>acquirep</code>的动作是<code>releasep</code>，把<strong>M</strong>装配的<strong>P</strong>给载掉；活干完了，地鼠需要休息了，就把小车还到停车场，然后睡觉去。</p>
<p>地鼠(<strong>M</strong>)拿到属于自己的小车(<strong>P</strong>)后，就进入工场开始干活了，也就是上面的 <code>schedule</code>调用。简化<code>schedule</code>的代码如下：</p>
<div class="language-c codeBlockContainer_Ckt0 theme-code-block" style=--prism-color:#f8f8f2;--prism-background-color:#272822><div class=codeBlockContent_biex><pre tabindex=0 class="prism-code language-c codeBlock_bY9V thin-scrollbar" style=color:#f8f8f2;background-color:#272822><code class=codeBlockLines_e6Vv><span class=token-line style=color:#f8f8f2><span class="token keyword" style=color:#66d9ef>static</span><span class="token plain"> </span><span class="token keyword" style=color:#66d9ef>void</span><span class="token plain"> </span><span class="token function" style=color:#e6db74>schedule</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token keyword" style=color:#66d9ef>void</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token plain"> </span><span class="token punctuation" style=color:#f8f8f2>{</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">    G </span><span class="token operator" style=color:#66d9ef>*</span><span class="token plain">gp</span><span class="token punctuation" style=color:#f8f8f2>;</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain"> </span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">    gp </span><span class="token operator" style=color:#66d9ef>=</span><span class="token plain"> </span><span class="token function" style=color:#e6db74>runqget</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token plain">m</span><span class="token operator" style=color:#66d9ef>-></span><span class="token plain">p</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token punctuation" style=color:#f8f8f2>;</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">    </span><span class="token keyword" style=color:#66d9ef>if</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token plain">gp </span><span class="token operator" style=color:#66d9ef>==</span><span class="token plain"> nil</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">        gp </span><span class="token operator" style=color:#66d9ef>=</span><span class="token plain"> </span><span class="token function" style=color:#e6db74>findrunnable</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token punctuation" style=color:#f8f8f2>;</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain"> </span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">    </span><span class="token keyword" style=color:#66d9ef>if</span><span class="token plain"> </span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token plain">m</span><span class="token operator" style=color:#66d9ef>-></span><span class="token plain">p</span><span class="token operator" style=color:#66d9ef>-></span><span class="token plain">runqhead </span><span class="token operator" style=color:#66d9ef>!=</span><span class="token plain"> m</span><span class="token operator" style=color:#66d9ef>-></span><span class="token plain">p</span><span class="token operator" style=color:#66d9ef>-></span><span class="token plain">runqtail </span><span class="token operator" style=color:#66d9ef>&&</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">        runtime</span><span class="token punctuation" style=color:#f8f8f2>.</span><span class="token function" style=color:#e6db74>atomicload</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token operator" style=color:#66d9ef>&</span><span class="token plain">runtime</span><span class="token punctuation" style=color:#f8f8f2>.</span><span class="token plain">sched</span><span class="token punctuation" style=color:#f8f8f2>.</span><span class="token plain">nmspinning</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token plain"> </span><span class="token operator" style=color:#66d9ef>==</span><span class="token plain"> </span><span class="token number" style=color:#ae81ff>0</span><span class="token plain"> </span><span class="token operator" style=color:#66d9ef>&&</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">        runtime</span><span class="token punctuation" style=color:#f8f8f2>.</span><span class="token function" style=color:#e6db74>atomicload</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token operator" style=color:#66d9ef>&</span><span class="token plain">runtime</span><span class="token punctuation" style=color:#f8f8f2>.</span><span class="token plain">sched</span><span class="token punctuation" style=color:#f8f8f2>.</span><span class="token plain">npidle</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token plain"> </span><span class="token operator" style=color:#66d9ef>></span><span class="token plain"> </span><span class="token number" style=color:#ae81ff>0</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token plain">  </span><span class="token comment" style=color:#8292a2;font-style:italic>// TODO: fast atomic</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">        </span><span class="token function" style=color:#e6db74>wakep</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token punctuation" style=color:#f8f8f2>;</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain"> </span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain">    </span><span class="token function" style=color:#e6db74>execute</span><span class="token punctuation" style=color:#f8f8f2>(</span><span class="token plain">gp</span><span class="token punctuation" style=color:#f8f8f2>)</span><span class="token punctuation" style=color:#f8f8f2>;</span><span class="token plain"></span><br></span><span class=token-line style=color:#f8f8f2><span class="token plain"></span><span class="token punctuation" style=color:#f8f8f2>}</span><br></span></code></pre><div class=buttonGroup__atx><button type=button aria-label="Copy code to clipboard" title=Copy class=clean-btn><span class=copyButtonIcons_eSgA aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_y97N><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_LjdS><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p><code>schedule</code>函数被我简化了太多，主要是我不喜欢贴大段大段的代码，因此只保留主干代码了。这里涉及到4大步逻辑：</p>
<ol>
<li><code>runqget</code>, 地鼠(<strong>M</strong>)试图从自己的小车(<strong>P</strong>)取出一块砖(<strong>G</strong>)，当然结果可能失败，也就是这个地鼠的小车已经空了，没有砖了。</li>
<li><code>findrunnable</code>, 如果地鼠自己的小车中没有砖，那也不能闲着不干活是吧，所以地鼠就会试图跑去工场仓库取一块砖来处理；工场仓库也可能没砖啊，出现这种情况的时候，这个地鼠也没有偷懒停下干活，而是悄悄跑出去，<strong>随机</strong>盯上一个小伙伴(地鼠)，然后从它的车里试图偷一半砖到自己车里。如果多次尝试偷砖都失败了，那说明实在没有砖可搬了，这个时候地鼠就会把小车还回停车场，然后 睡觉休息了。如果地鼠睡觉了，下面的过程当然都停止了，地鼠睡觉也就是线程<code>sleep</code>了。</li>
<li><code>wakep</code>, 到这个过程的时候，可怜的地鼠发现自己小车里有好多砖啊，自己根本处理不过来；再回头一看停车场居然有闲置的小车，立马跑到宿舍一看，你妹，居然还有小伙伴在睡觉，直接给屁股一脚，“你妹，居然还在睡觉，老子都快累死了，赶紧起来干活，分担点工作。”，小伙伴醒了，拿上自己的小车，乖乖干活去了。有时候，可怜的地鼠跑到宿舍却发现没有在睡觉的小伙伴，于是会很失望，最后只好向工场老板说——”停车场还有闲置的车啊，我快干不动了，赶紧从别的工场借个地鼠来帮忙吧。”，最后工场老板就搞来一个新的地鼠干活了。</li>
<li><code>execute</code>，地鼠拿着砖放入火种欢快的烧练起来。</li>
</ol>
<p>注： "地鼠偷砖"叫 <a href=http://supertech.csail.mit.edu/papers/steal.pdf target=_blank rel="noopener noreferrer">work stealing</a>，一种调度算法。</p>
<p>到这里，貌似整个工场都正常的运转起来了，无懈可击的样子。不对，还有一个疑点没解决啊，假设地鼠的车里有很多砖，它把一块砖放入火炉中后，何时把它取出来，放入第二块砖呢？难道要一直把第一块砖烧练好，才取出来吗？那估计后面的砖真的是等得花儿都要谢了。这里就是要真正解决<code>goroutine</code>的调度，上下文切换问题。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=调度点>调度点<a href=#调度点 class=hash-link aria-label="Direct link to 调度点" title="Direct link to 调度点">​</a></h3>
<p>当我们翻看<code>channel</code>的实现代码可以发现，<strong>对</strong><code>channel</code><strong>读写</strong>操作的时候会触发调用 <code>runtime.park </code> 函数。<code>goroutine</code>调用<code>park</code>后，这个<code>goroutine</code>就会被设置位<code>waiting</code>状态，放弃<strong>CPU</strong>。被<code>park</code>的<code>goroutine</code>处于<code>waiting</code>状态，并且这个<code>goroutine</code>不在小车(<strong>P</strong>)中，如果不对其调用<code>runtime.ready</code>，它是永远不会再被执行的。<strong>除了channel操作外，定时器、网络poll等都有可能park goroutine</strong>。</p>
<p><strong>除了park可以放弃cpu外</strong>，调用 <code> runtime.gosched </code> 函数也可以让当前<code>goroutine</code>放弃<strong>CPU</strong>，但和<code>park</code>完全不同；<code>gosched</code>是将<code>goroutine</code>设置为<code>runnable</code>状态，然后放入到调度器全局等待队列（也就是上面提到的工场仓库，这下就明白为何工场仓库会有砖块(<strong>G</strong>)了吧）。</p>
<p><strong>除此之外，就轮到系统调用了，有些系统调用也会触发重新调度</strong>。<strong>Go语言完全是自己封装的系统调用</strong>，所以在封装系统调用的时候，可以做不少手脚，也就是进入系统调用的时候执行<code>entersyscall</code>，退出后又执行<code>exitsyscall</code>函数。 <strong>也只有封装了</strong><code>entersyscall</code><strong>的系统调用才有可能触发重新调度</strong>，它将改变小车(<strong>P</strong>)的状态为<code>syscall</code>。还记一开始提到的<code>sysmon</code>线程吗？这个系统监控线程会扫描所有的小车(<strong>P</strong>)，发现一个小车(<strong>P</strong>)处于了<code>syscall</code>的状态，就知道这个小车(<strong>P</strong>)遇到了<code>goroutine</code>在做系统调用，于是系统监控线程就会创建一个新的地鼠(<strong>M</strong>)去把这个处于<code>syscall</code>的小车给抢过来，开始干活，这样这个小车中的所有砖块(<strong>G</strong>)就可以绕过之前系统调用的等待了。被抢走小车的地鼠等系统调用返回后，发现自己的车没，不能继续干活了，于是只能把执行系统调用的<code>goroutine</code>放回到工场仓库，自己睡觉去了。</p>
<p>从<code>goroutine</code>的调度点可以看出，调度器还是挺粗暴的，调度粒度有点过大，公平性也没有想想的那么好。总之，这个调度器还是比较简单的。</p>
<p>综上所述，<code>goroutine</code>上下文切换的调度时机可分为以下几个条件：</p>
<ol>
<li><code>goroutine</code>阻塞(<code>waiting</code>)</li>
<li>显式调用<code>runtime.gosched()</code></li>
<li>系统调用<code>system call</code></li>
</ol>
<p><strong>协程一般都是这样工作的，但是从1.2开始，为了避免饿死其它goroutine，就是在发生任意函数调用的时候，都有机会触发scheduler。所以从1.2开始如果你的goroutine中是纯计算，没有任何系统调用，scheduler仍然有机会介入，不会永远独占CPU。</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=现场处理>现场处理<a href=#现场处理 class=hash-link aria-label="Direct link to 现场处理" title="Direct link to 现场处理">​</a></h3>
<p><code>goroutine</code>在<strong>CPU</strong>上换入换出，不断上下文切换的时候，必须要保证的事情就是 <strong>保存现场</strong> 和 <strong>恢复现场</strong>，保存现场就是在<code>goroutine</code>放弃<strong>CPU</strong>的时候，将相关<strong>寄存器的值</strong>给保存到内存中；恢复现场就是在<code>goroutine</code>重新获得<strong>CPU</strong>的时候，需要从内存把之前的寄存器信息全部放回到相应寄存器中去。 Go 调度器 M 的栈保存在 G 对象上，只需要将 M 所需要的寄存器（ SP、 PC 等） 保存到 G 对象上就可以实现现场保护。当这些寄存器数据被保护起来，就随时可以做上下文切换了，在中断之前把现场保存起来。如果此时G 任务还没有执行完， M 可以将任务重新丢到 P 的任务队列，等待下一次被调度执行。当再次被调度执行时， M 通过访问 G 的 <code>vdsoSP</code>、 <code>vdsoPC</code>寄存器进行现场恢复（ 从上次中断位置继续执行） 。</p>
<p><code>goroutine</code>在主动放弃<strong>CPU</strong>的时候(<code>park/gosched</code>)，都会涉及到调用<code>runtime.mcall</code>函数，此函数也是汇编实现，主要将<code>goroutine</code>的栈地址和程序计数器保存到<strong>G</strong>结构的<code>sched</code>字段中，<code>mcall</code>就完成了现场保存。恢复现场的函数是<code>runtime.gogocall</code>，这个函数主要在<code>execute</code>中调用，就是在执行<code>goroutine</code>前，需要重新装载相应的寄存器。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=三参考链接>三、参考链接<a href=#三参考链接 class=hash-link aria-label="Direct link to 三、参考链接" title="Direct link to 三、参考链接">​</a></h2>
<ul>
<li>
<p><a href=https://johng.cn/goroutine1-pmg/ target=_blank rel="noopener noreferrer">https://johng.cn/goroutine1-pmg/</a></p>
</li>
<li>
<p><a href=https://johng.cn/goroutine-scheduler-brief/ target=_blank rel="noopener noreferrer">https://johng.cn/goroutine-scheduler-brief/</a></p>
</li>
<li>
<p><a href=https://www.zhihu.com/question/20862617 target=_blank rel="noopener noreferrer">https://www.zhihu.com/question/20862617</a></p>
</li>
<li>
<p><a href=http://morsmachine.dk/go-scheduler target=_blank rel="noopener noreferrer">http://morsmachine.dk/go-scheduler</a></p>
</li>
</ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href=/programming/golang><div class=pagination-nav__sublabel>Previous</div><div class=pagination-nav__label>Golang</div></a><a class="pagination-nav__link pagination-nav__link--next" href=/programming/golang-mutex-principle><div class=pagination-nav__sublabel>Next</div><div class=pagination-nav__label>Golang Mutex 原理解析</div></a></nav><div class=docusaurus-mt-lg></div></div></div><div class="col col--3"><div class=tocContainer_PXzm><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#一pmg关系 class="table-of-contents__link toc-highlight">一、P、M、G关系</a><li><a href=#二调度流程简述 class="table-of-contents__link toc-highlight">二、调度流程简述</a><ul><li><a href=#启动过程 class="table-of-contents__link toc-highlight">启动过程</a><li><a href=#创建goroutineg class="table-of-contents__link toc-highlight">创建goroutine(G)</a><li><a href=#创建内核线程m class="table-of-contents__link toc-highlight">创建内核线程(M)</a><li><a href=#调度核心 class="table-of-contents__link toc-highlight">调度核心</a><li><a href=#调度点 class="table-of-contents__link toc-highlight">调度点</a><li><a href=#现场处理 class="table-of-contents__link toc-highlight">现场处理</a></ul><li><a href=#三参考链接 class="table-of-contents__link toc-highlight">三、参考链接</a></ul></div><div class=tocAdBanner_imxD></div></div></div></div></div></main></div></div></div><footer class=footer><div class="container container-fluid"><div class="footer__bottom text--center"><div class=footer__copyright>Copyright 2025 johng.cn</div></div></div></footer></div>