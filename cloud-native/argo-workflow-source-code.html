<!doctype html><html lang=en dir=ltr class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-docs/云原生/Argo Workflow/Argo Workflow源码解析" data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.6.3"><title data-rh=true>Argo Workflow源码解析 | John's Blog</title><meta data-rh=true name=viewport content="width=device-width,initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:url content=https://johng.cn/cloud-native/argo-workflow-source-code><meta data-rh=true property=og:locale content=en><meta data-rh=true name=docusaurus_locale content=en><meta data-rh=true name=docsearch:language content=en><meta data-rh=true name=docusaurus_version content=current><meta data-rh=true name=docusaurus_tag content=docs-default-current><meta data-rh=true name=docsearch:version content=current><meta data-rh=true name=docsearch:docusaurus_tag content=docs-default-current><meta data-rh=true property=og:title content="Argo Workflow源码解析 | John's Blog"><meta data-rh=true name=description content="深入分析 Argo Workflow 的源代码实现，探讨其核心组件、工作流程和关键功能的技术细节"><meta data-rh=true property=og:description content="深入分析 Argo Workflow 的源代码实现，探讨其核心组件、工作流程和关键功能的技术细节"><meta data-rh=true name=keywords content="Argo Workflow,源码分析,工作流引擎,Kubernetes,Go语言,代码实现"><link data-rh=true rel=icon href=/img/favicon.ico><link data-rh=true rel=canonical href=https://johng.cn/cloud-native/argo-workflow-source-code><link data-rh=true rel=alternate href=https://johng.cn/cloud-native/argo-workflow-source-code hreflang=en><link data-rh=true rel=alternate href=https://johng.cn/cloud-native/argo-workflow-source-code hreflang=x-default><link data-rh=true rel=preconnect href=https://XGS1CPQERK-dsn.algolia.net crossorigin><link rel=search type=application/opensearchdescription+xml title="John's Blog" href=/opensearch.xml><script src=https://hm.baidu.com/hm.js?6b4ae23dc83ee5efe875b7172af6c7c1 async></script><script src=https://cdn.wwads.cn/js/makemoney.js async></script><link rel=stylesheet href=/assets/css/styles.96de5670.css><script src=/assets/js/runtime~main.d348b943.js defer></script><script src=/assets/js/main.a16bd09c.js defer></script><body class=navigation-with-keyboard><script>!function(){var t,e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t=null!==e?e:"light",document.documentElement.setAttribute("data-theme",t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><div role=region aria-label="Skip to main content"><a class=skipToContent_fXgn href=#__docusaurus_skipToContent_fallback>Skip to main content</a></div><nav aria-label=Main class="navbar navbar--fixed-top"><div class=navbar__inner><div class=navbar__items><button aria-label="Toggle navigation bar" aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/><b class="navbar__title text--truncate">John's Blog</b></a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/architecture>技术架构</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/programming>开发语言</a><a aria-current=page class="navbar__item navbar__link navbar__link--active" sidebarid=mainSidebar href=/cloud-native>云原生</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/observability>可观测性</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/database-and-middleware>数据库与中间件</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/notes>日常笔记</a><a class="navbar__item navbar__link" href=/aboutme>关于我</a></div><div class="navbar__items navbar__items--right"><a href=https://goframe.org/ target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-goframe-link"></a><a href=https://github.com/gqcn target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class=navbarSearchContainer_Bca1><button type=button class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 20 20" aria-hidden=true><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke=currentColor fill=none fill-rule=evenodd stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>Search</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="main-wrapper mainWrapper_z2l0"><div class=docsWrapper_hBAB><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type=button></button><div class=docRoot_UBD9><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class=sidebarViewport_aRkj><div class=sidebar_njMd><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/architecture>技术架构</a><button aria-label="Expand sidebar category '技术架构'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/management>技术管理</a><button aria-label="Expand sidebar category '技术管理'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/programming>开发语言</a><button aria-label="Expand sidebar category '开发语言'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist menu__link--active" href=/cloud-native>云原生</a><button aria-label="Collapse sidebar category '云原生'" aria-expanded=true type=button class="clean-btn menu__caret"></button></div><ul style=display:block;overflow:visible;height:auto class=menu__list><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" tabindex=0 href=/cloud-native/kubernetes>Kubernetes</a><button aria-label="Expand sidebar category 'Kubernetes'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist menu__link--active" tabindex=0 href=/cloud-native/argo-workflow>Argo Workflow</a><button aria-label="Collapse sidebar category 'Argo Workflow'" aria-expanded=true type=button class="clean-btn menu__caret"></button></div><ul style=display:block;overflow:visible;height:auto class=menu__list><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/cloud-native/argo-workflow-introduction>Argo Workflow介绍</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current=page tabindex=0 href=/cloud-native/argo-workflow-source-code>Argo Workflow源码解析</a><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-3 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" tabindex=0 href=/cloud-native/argo-workflow-faq>Argo Workflow常见问题</a><button aria-label="Expand sidebar category 'Argo Workflow常见问题'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/cloud-native/argo-workflow-development-setup>Argo Workflow开发环境搭建</a></ul><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" tabindex=0 href=/cloud-native/volcano>Volcano</a><button aria-label="Expand sidebar category 'Volcano'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/cloud-native/dragonfly>Dragonfly介绍</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/cloud-native/docker-containerd-commands>Docker和Containerd常用命令对比</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/cloud-native/kubernetes-kind>使用Kubernetes Kind搭建本地测试集群</a></ul><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/ai>AI技术</a><button aria-label="Expand sidebar category 'AI技术'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/observability>可观测性</a><button aria-label="Expand sidebar category '可观测性'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/database-and-middleware>数据库与中间件</a><button aria-label="Expand sidebar category '数据库与中间件'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/operating-systems-and-networks>操作系统和网络</a><button aria-label="Expand sidebar category '操作系统和网络'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/notes>日常笔记</a><button aria-label="Expand sidebar category '日常笔记'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div></ul></nav></div></div></aside><main class=docMainContainer_TBSr><div class="container padding-top--md padding-bottom--lg"><div class=row><div class="col docItemCol_VOVn"><div class=docItemContainer_Djhp><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label=Breadcrumbs><ul class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li class=breadcrumbs__item><a aria-label="Home page" class=breadcrumbs__link href=/><svg viewBox="0 0 24 24" class=breadcrumbHomeIcon_YNFT><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill=currentColor /></svg></a><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class=breadcrumbs__item><a class=breadcrumbs__link itemprop=item href=/cloud-native><span itemprop=name>云原生</span></a><meta itemprop=position content=1><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class=breadcrumbs__item><a class=breadcrumbs__link itemprop=item href=/cloud-native/argo-workflow><span itemprop=name>Argo Workflow</span></a><meta itemprop=position content=2><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class="breadcrumbs__item breadcrumbs__item--active"><span class=breadcrumbs__link itemprop=name>Argo Workflow源码解析</span><meta itemprop=position content=3></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type=button class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><p>本文主要对Argo Workflow的核心Feature以及核心执行流程的源码实现进行解析讲解，Feature的实现细节请翻看Argo Workflow源码进行更深入的了解。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=一知识梳理>一、知识梳理<a href=#一知识梳理 class=hash-link aria-label="Direct link to 一、知识梳理" title="Direct link to 一、知识梳理">​</a></h2>
<p>由于Argo本身的概念和内容较多，我这里先通过思维导图的方式梳理出其中较为关键的知识点，作为前置预备知识：</p>
<p><a href=https://whimsical.com/kubernetes-argo-framework-UZXKpyqfjqMzRx6mxuEdNt@2Ux7TurymN5ZuzLYocBL target=_blank rel="noopener noreferrer">https://whimsical.com/kubernetes-argo-framework-UZXKpyqfjqMzRx6mxuEdNt@2Ux7TurymN5ZuzLYocBL</a></p>
<p>一些基本的概念和功能介绍这里不再赘述，可以参考之前的一篇Argo介绍文章：<a href=/cloud-native/argo-workflow-introduction>Argo Workflow介绍</a></p>
<p><img decoding=async loading=lazy src=/assets/images/KubernetesArgoFramework-66e54d3315b3ac75a01e6b26b3c7121c.png width=2487 height=1418 class=img_ev3q></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=二充满好奇>二、充满好奇<a href=#二充满好奇 class=hash-link aria-label="Direct link to 二、充满好奇" title="Direct link to 二、充满好奇">​</a></h2>
<p>为了更好地学习Argo Workflow，这里有几个问题，我们带着问题去探究Argo效果可能会更好一些：</p>
<ol>
<li>Workflow有哪些核心组件，各自的作用是什么？</li>
<li>Workflow的流程数据是如何实现上下文传递的？</li>
<li>Workflow的流程管理逻辑是如何实现的？</li>
<li>Workflow的模板以及状态数据存储在哪里？</li>
</ol>
<p>接下来我们先梳理一下Argo Workflow的核心流程以及一些关键逻辑，然后我们再回过头来解答这些问题。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=三工程结构>三、工程结构<a href=#三工程结构 class=hash-link aria-label="Direct link to 三、工程结构" title="Direct link to 三、工程结构">​</a></h2>
<p><code>Argo Workflow</code>的整个工程是使用经典的<code>kubebuilder</code>搭建的，因此大部分目录结构和<code>kubebuilder</code>保持一致。关于<code>kubebuilder</code>的介绍可参考：<a href=https://cloudnative.to/kubebuilder/ target=_blank rel="noopener noreferrer">https://cloudnative.to/kubebuilder/</a></p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_15-15-13-bcc45a92fb777055f25cb57eb86270b4.png width=828 height=1722 class=img_ev3q></p>
<table><thead><tr><th>目录名称<th>职责及说明<tbody><tr><td><code>api</code><td>Swagger API 定义Json文件存放目录，主要是供Argo Server UI使用。<tr><td><code>cmd</code><td>入口源码文件<tr><td> <code> - argo</code><td><code>argo CLI</code><tr><td> <code> - argoexec</code><td><code>argoexec container image</code>命令<tr><td> <code> - workflow-controller</code><td><code>Kubernetes CRD Controller</code><tr><td><code>community</code><td>开源社区相关介绍，目前就一个README.MD<tr><td><code>config</code><td><code>Argo Workflow Controller</code>配置对象以及相关方法<tr><td><code>docs</code><td><code>Argo Workflow</code>的相关介绍文档，与官网文档一致<tr><td><code>errors</code><td>封装第三方 <code>[github.com/pkg/errors](http://github.com/pkg/errors)</code> 组件，<code>argo Workflow</code>内部使用的错误管理组件<tr><td><code>examples</code><td>丰富的使用示例，主要是yaml文件<tr><td><code>hack</code><td>项目使用到的脚本及工具文件<tr><td><code>manifests</code><td><code>Argo</code>的安装配置文件，都是些<code>yaml</code>文件，使用<code>kustomize</code>工具管理，关于kustomize工具的介绍请参考：<a href=https://kubernetes.io/zh/docs/tasks/manage-kubernetes-objects/kustomization/ target=_blank rel="noopener noreferrer">https://kubernetes.io/zh/docs/tasks/manage-kubernetes-objects/kustomization/</a><tr><td><code>persist</code><td>Argo数据库持久化封装组件，支持MySQL/PostgreSQL两种数据库。持久化主要是针对于<code>Archived Workflow</code>对象的存储，包含Workflow的定义以及状态数据。<tr><td><code>pkg</code><td><code>Argo Workflow</code>的对外API定义、结构定义、客户端定义，主要提供给外部服务、客户端使用。<tr><td> <code> - apiclient</code><td><code>Argo Server</code>对外<code>API</code>相关定义、客户端组件。<tr><td> <code> - workflow</code><td><code>Argo Workflow Controller</code>相关结构体定义。<tr><td> <code> - client</code><td><code>Argo Workflow Controller</code>与<code>Kubernetes</code>交互的<code>Client/Informer/Lister</code>定义。<tr><td><code>server</code><td><code>Argo Server</code>模块。<tr><td><code>test</code><td>单元测试文件。<tr><td><code>ui</code><td><code>Argo Server</code>的前端<code>UI NodeJS</code>源码文件，使用<code>Yarn</code>包管理。<tr><td><code>util</code><td>项目封装的工具包模块<tr><td><code>workflow</code><td><code>Argo Workflow</code>的核心功能逻辑封装</table>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=四workflow-controller>四、Workflow Controller<a href=#四workflow-controller class=hash-link aria-label="Direct link to 四、Workflow Controller" title="Direct link to 四、Workflow Controller">​</a></h2>
<p><code>Argo</code>中最核心也最复杂的便是<code>Workflow Controller</code>的实现。<code>Argo Workflow Controller</code>的主要职责是<code>CRD</code>的实现，以及<code>Pod</code>的创建创建。由于<code>Argo</code>采用的是<code>Kubernetes CRD</code>设计，因此整体架构以及流程控制采用的是<code>Kubernetes Informer</code>实现，相关背景知识可以参考之前的两篇文章：<a href=/cloud-native/kubernetes-informer-client-go>Kubernetes Informer及client-go资料</a>、<a href=/cloud-native/kubernetes-crd-controller-operator>Kubernetes CRD, Controller, Operator</a>。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=1基本架构>1、基本架构<a href=#1基本架构 class=hash-link aria-label="Direct link to 1、基本架构" title="Direct link to 1、基本架构">​</a></h3>
<p><img decoding=async loading=lazy src=/assets/images/architecture-da80fb251eaeef0d44e5895e061bc771.jpeg width=1810 height=1198 class=img_ev3q></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=2重要设计>2、重要设计<a href=#2重要设计 class=hash-link aria-label="Direct link to 2、重要设计" title="Direct link to 2、重要设计">​</a></h3>
<p><code>Argo Workflow Controller</code>组件有一些，我个人觉得较为重要的设计给大家分享下。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=1定义与状态分离>1）定义与状态分离<a href=#1定义与状态分离 class=hash-link aria-label="Direct link to 1）定义与状态分离" title="Direct link to 1）定义与状态分离">​</a></h4>
<p>这个其实是<code>Kubernetes</code>的标准设计，即<code>CRD实现</code>对象应当包含<code>Spec</code>及<code>Status</code>属性对象，其中<code>Spec</code>对应<code>CR</code>的定义，而<code>Status</code>对应<code>CR</code>的业务状态信息。<code>Spec</code>由业务客户端创建和修改，一般创建后不会更新，在<code>Informer Controller</code>处理流程中只能读取。而<code>Status</code>是<code>Informer Controller</code>中根据业务场景的需要不断变化的字段。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=2定义与数据分离>2）定义与数据分离<a href=#2定义与数据分离 class=hash-link aria-label="Direct link to 2）定义与数据分离" title="Direct link to 2）定义与数据分离">​</a></h4>
<p><code>Argo Workflow Template</code>应当只包含流程以及变量定义，而变量数据则是由运行时产生的，例如通过Template运行时生成到终端或者<code>Artifact</code>，再通过<code>Outputs</code>的定义被其他的Template引用。一个<code>Node</code>执行成功之后，它的输出数据将会被保存到<code>Template.Status</code>字段（<code>Kubernetes etcd</code>）或者Artifact中，返回执行不会重复生成。一个<code>Node</code>执行失败后，如果重新执行将会重新去拉取依赖的数据。这种定义与数据分离的设计使得<code>Workflow Template</code>可以预先设计，甚至可以通过UI拖拽的方式生成。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=3全局与局部变量>3）全局与局部变量<a href=#3全局与局部变量 class=hash-link aria-label="Direct link to 3）全局与局部变量" title="Direct link to 3）全局与局部变量">​</a></h4>
<p><code>在Argo Workflow Controller</code>内部中的变量分为两种:一种是<code>Workflow</code>全局生效的变量(<code>globalParams</code>)，一种是当前<code>Template</code>生效的本地变量(<code>localParams</code>)。其中全局变量也包括开发者自定义的输入/输出变量、<code>Workflow Annotations&Labels</code>，这些变量也是能被<code>Workflow</code>全局中访问。两种变量由于访问方式不同，因此不会相互冲突。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=4模板化变量设计>4）模板化变量设计<a href=#4模板化变量设计 class=hash-link aria-label="Direct link to 4）模板化变量设计" title="Direct link to 4）模板化变量设计">​</a></h4>
<p><code>Argo Workflow Controller</code>的变量其实主要是使用到模板解析中。在<code>Controller</code>处理流程中，会看到多次的<code>json.Marshal/json.Unmarshal</code>操作：通过<code>json.Marhsal</code>将<code>Template</code>对象转为字符串，再通过模板解析将字符串中的变量替换为真正的内容，随后再将字符串<code>json.Unmarshal</code>到该对象上覆盖原有属性值。这种设计也使得<code>Workflow Template</code>中的变量对应的内容必须是一个具体的值（字符串/数字等基本类型），不能是一个复杂对象，否则无法完成模板解析替换。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=5多模板融合设计>5）多模板融合设计<a href=#5多模板融合��设计 class=hash-link aria-label="Direct link to 5）多模板融合设计" title="Direct link to 5）多模板融合设计">​</a></h4>
<p>在<code>Argo Workflow</code>中有三个地方可以设置<code>Template</code>运行模板，按照优先级顺序为：<code>Default Template、Workflow Template和Node Template</code>。</p>
<p><code>**Default Template**</code>: 全局Template定义，所有创建的Workflow都会自动使用到该Template定义。</p>
<p><code>**Workflow Template**</code>: Workflow流程中所有Node都会使用到的Template定义。</p>
<p><code>**Node Template**</code>: 使用Steps/DAG流程调度的各个步骤/任务Node使用到的Template。</p>
<p>优先级高的<code>Template</code>在运行时会覆盖优先级低的<code>Template</code>，最终融合生成的Template再使用到<code>Pod</code>的创建中。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=6简化的调度控制>6）简化的调度控制<a href=#6简化的调度控制 class=hash-link aria-label="Direct link to 6）简化的调度控制" title="Direct link to 6）简化的调度控制">​</a></h4>
<p><code>Argo Workflow</code>目前仅使用两种调度控制方式：<code>Steps</code>和<code>DAG</code>。</p>
<p><code>Steps:</code> 通过步骤的先后顺序、并行/串行控制来调度执行任务。</p>
<p><code>DAG:</code> 通过有向无环图，任务之间的依赖关系来调度执行任务。</p>
<p>并且这两种方式可以混合使用，使得<code>Argo Workflow</code>基本能满足绝大部分的任务调度业务场景。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=3核心结构>3、核心结构<a href=#3核心结构 class=hash-link aria-label="Direct link to 3、核心结构" title="Direct link to 3、核心结构">​</a></h3>
<p>整个<code>Controller</code>逻辑中涉及到的核心数据结构如下。</p>
<table><thead><tr><th>数据结构<th>结构介绍<tbody><tr><td><code>WorkflowController</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-1_11-14-52-0b19344240c07be0b3a66621ea2ceaa2.png width=2292 height=2512 class=img_ev3q><br><br>用于<code>Workflow Controller</code>流程控制的核心数据结构对象，封装了主要的<code>Controller</code>处理逻辑、维护着核心的相关业务逻辑对象、数据队列、<code>KubeClient</code>对象、<code>Informer</code>对象等等。该结构只有一个对象实例，由主流程创建。<tr><td><code>Workflow</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-1_11-18-1-da115e237d956dd8176ff7a9a1157652.png width=2780 height=682 class=img_ev3q><br><br><code>Workflow</code>的内容管理对象，用于<code>Workflow</code>的逻辑处理。<tr><td><code>WorkflowSpec</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-1_11-19-10-c525bb3158e92ddaa2db6723fb7311f5.png width=3552 height=2592 class=img_ev3q><br><br><code>Workflow</code>的内容定义映射对象，与开发者使用的<code>yaml</code>文件结构一一对应。需要注意与<code>WorkflowStatus</code>的区别：<br><br>*   <code>WorkflowSpec</code>是<code>Workflow</code>的定义，来源于<code>Workflow Yaml</code>配置以及对象初始化。初始化完成后再运行时不会执行修改操作，运行时操作中只对<code>Spec</code>对象执行读取操作。<br>*   <code>WorkflowStatus</code>是<code>Workflow</code>运行时的状态信息管理对象，因为状态信息会不断变化，因此内部的属性也会不停地被修改。<tr><td><code>WorkflowStatus</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-1_11-21-30-f67fdf4278dad8a4c4ba31a7f54551a7.png width=2930 height=2596 class=img_ev3q><br><br><code>Workflow</code>逻辑处理流程中的运行时状态信息管理对象。该结构是与<code>Kubernetes Pod操作相关的资源结构。几点重要的说明：</code><br><br><code>1、StoredTemplates</code><br><br>该属性是一个<code>Map</code>类型，存放了当前<code>Workflow</code>所有的<code>Template</code>对象，以便于全局访问。键名为生成的<code>TemplateID</code>，生成规则为：<br><br><code>Scope/MetaName/TemplateName</code><br><br><img decoding=async loading=lazy src=/assets/images/image2021-7-1_17-42-37-4b258760bc1734a886a4de40552c8855.png width=2548 height=1040 class=img_ev3q><tr><td><code>WorkflowStep</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-1_17-6-38-41a18fbb6c1d3ff9acb9016b1b1fcbe6.png width=2022 height=2126 class=img_ev3q><br><br>是的，你没猜错，这个是用来管理执行流程控制的每一个操作步骤对象。该步骤对象必然会绑定一个<code>Template</code>对象。<br><br><code>Workflow</code>的初始化执行步骤是通过<code>woc.execWf.Spec.Entrypoint</code> 作为入口<code>Template</code>。<tr><td><code>wfOperationCtx</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-1_11-27-8-d06b873b5f61066b140779a7dcb50b26.png width=2334 height=2504 class=img_ev3q><br><br><code>Workflow</code>业务逻辑封装对象。<br><br>几点重要的说明：<br><br>1、<code>wf/orig/execWf</code><br><br>1）<code>wf</code><br><br>该对象是开发者通过<code>yaml</code>创建的<code>Workflow</code>对象的深度拷贝对象。官方注释建议运行时逻辑处理中应当使用<code>execWf</code>而不是<code>wf</code>对象，wf对象未来可能会被废弃掉。<br><br>2）<code>orig</code><br><br>该对象是开发者通过<code>yaml</code>创建的<code>Workflow</code>对象，任何时候开发者都不应当去修改它，该对象主要用于后续可以对<code>Workflow</code>的<code>patch</code>更新判断。<br><br>3）<code>execWf</code><br><br>该对象是运行时逻辑处理中修改的<code>Workflow</code>对象，因为<code>Workflow</code>对象会在逻辑处理中不断被修改更新，特别是<code>execWf</code>是多个模板<code>(Wf/WfDefault/WfTemplate)</code>的合并结构。<br><br>*   关于<code>TemplateDefault</code>的介绍请参考官方文档：<a href=https://argoproj.github.io/argo-workflows/template-defaults/ target=_blank rel="noopener noreferrer">https://argoproj.github.io/argo-workflows/template-defaults/</a><br>*   <code>WfTemplate</code>来源于<code>templateRef</code>配置，具体请参考官方文档：<a href=https://argoproj.github.io/argo-workflows/workflow-templates/#referencing-other-workflowtemplates target=_blank rel="noopener noreferrer">https://argoproj.github.io/argo-workflows/workflow-templates/#referencing-other-workflowtemplates</a><br><br>2、<code>globalParams</code><br><br>全局变量，类型为<code>map[string]string</code>，该<code>Workflow</code>中的所有<code>template</code>共享该变量，该变量的名称也可被用于<code>template</code>中的模板变量。<br><br>3、<code>update</code><br><br>该属性用于标识当前<code>Workflow</code>对象是否已更新，以便判断是否同步到<code>Kubernetes</code>中。<br><br>4、<code>node</code><br><br>在<code>woc</code>处理流程的源码中会出现<code>node</code>的概念，这里的<code>node</code>是<code>Steps/DAG中</code>的执行节点，每一个节点都会运行一个<code>Pod</code>来执行。注意它和<code>Template</code>不是一个概念。<tr><td><code>templateresolution.</code><br><br><code>Context</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-1_16-56-26-a4c610c20fc7e6ac27e6f1d15b0fd60d.png width=1386 height=676 class=img_ev3q><br><br>如注释所示，用于<code>Workflow</code>中的<code>template</code>检索。</table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=4核心流程>4、核心流程<a href=#4核心流程 class=hash-link aria-label="Direct link to 4、核心流程" title="Direct link to 4、核心流程">​</a></h3>
<p>主要节点流程图：<a href=https://whimsical.com/kubernetes-argo-controller-4BkPmeF1ZNP548D3JmaHhS@2Ux7TurymME7dMV1vz75 target=_blank rel="noopener noreferrer">https://whimsical.com/kubernetes-argo-controller-4BkPmeF1ZNP548D3JmaHhS@2Ux7TurymME7dMV1vz75</a></p>
<p>由于<code>Argo Workflow Controller</code>的细节很多、流程非常长，这里对流程做了精简，只保留了相对比较重要的执行节点，以便有侧重性进行介绍。</p>
<p><img decoding=async loading=lazy src=/assets/images/KubernetesArgoController-a75667d3a0428abbf33368804985e4f8.png width=2270 height=2187 class=img_ev3q></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=1workflowcontroller><code>1）WorkflowController</code><a href=#1workflowcontroller class=hash-link aria-label="Direct link to 1workflowcontroller" title="Direct link to 1workflowcontroller">​</a></h4>
<ul>
<li><code>![](/attachments/image2021-7-2_10-6-9.png)  </code></li>
</ul>
<p><code>Controller</code>启动是由<code>Cobra</code>命令行组件管理，通过<code>workflow-controller</code>命令执行启动。启动后创建<code>WorkflowController</code>对象，并执行该对象的<code>Run</code>方法将流程的控制交给了该对象维护。这里同时会创建一个<code>HTTP Serever:``6060/healthz</code>，用于<code>Controller容器</code>的健康检查。不过，从执行结果来看，<code>6060</code>端口的健康检查服务并没有被使用，而是使用的后续开启的<code>Metrics Http Server</code>作为健康检查的地址。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-2_10-23-20-99c738b9a6b41011cb929659a0296c8a.png width=2760 height=2600 class=img_ev3q></p>
<ul>
<li>在初始化<code>WorkflowController</code>时会自动创建内部的一个<code>Informer</code>对象<code>Watch ConfigMap</code>的变化，当<code>argo</code>的相关<code>ConfigMap</code>更新后，会自动更新<code>wfc</code>的相关配置，包括数据库连接<code>Session</code>。</li>
</ul>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-2_15-42-36-83886c306df5b0d25f411423db57940a.png width=1564 height=1156 class=img_ev3q></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=2wfcontrollerrun><code>2）wfController.Run</code><a href=#2wfcontrollerrun class=hash-link aria-label="Direct link to 2wfcontrollerrun" title="Direct link to 2wfcontrollerrun">​</a></h4>
<p><code>WorkflowCotroller</code>首先会进行大量的初始化操作，主要如下：</p>
<ul>
<li>创建<code>wfc.wfInformer/wfc.wftmplInformer/wfc.podInformer/wfc.cwftmplInformer</code>并绑定相关的<code>Event Handler</code>，根据各自设定的<code>cache.ListWatch</code>规则对<code>Event</code>进行过滤（只会监听<code>argo</code>创建的相关资源）。例如：</li>
</ul>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-2_15-51-15-aaec0571892ea3048fa120d5b70ca81c.png width=1456 height=836 class=img_ev3q></p>
<ul>
<li>创建<code>Metrics Http Server:9090</code>，用于<code>Prometheus</code>的指标上报，内部的指标有点多，可以单独创建一个话题来研究，这里就不深究了。</li>
<li>经典的<code>Kubernetes Client Leader</code>选举逻辑，当选出<code>Leader</code>时，在<code>Leader</code>节点通过<code>OnStartedLeading</code>回调进入<code>wfc.startLeading</code>逻辑。</li>
<li><code>wfc.startLeading</code>中开始队列的开启、异步任务的创建，这里使用了<code>wait.Until</code>方法，该方法会每隔一段时间创建一个异步的协程执行。</li>
<li>这里涉及到3个队列的<code>worker</code>创建：<code>wfc.wfQueue/wfc.podQueue/wfc.podCleanupQueue</code>：<!-- -->
<ul>
<li><code>wfc.wfQueue</code> 用于核心的Workflow对象的创建/修改流程控制。</li>
<li><code>wfc.podQueue</code> 用于<code>Pod</code>的更新，其实就是当<code>Pod</code>有更新时如果<code>Pod</code>还存在，那么重新往<code>wfc.wfQueue</code>中添加一条数据重新走一遍<code>Workflow</code>的流程对<code>Pod</code>执行修改。</li>
<li><code>wfc.podCleanupQueue</code> 用于<code>Pod</code>的标记完成。关闭：先关闭<code>main container</code>，再关闭<code>wait container</code>（关闭时先发送<code>syscall.SIGTERM</code>再发送<code>syscall.SIGKILL</code>信号）。删除：直接从<code>Kubernetes</code>中<code>Delete</code>该<code>Pod</code>。</li>
<li>官方的架构图中也能看得到几个队列之间的关联关系。</li>
</ul>
</li>
</ul>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-2_16-19-31-a64ee6803594cd9b3213092e53f3f3bc.png width=2030 height=1298 class=img_ev3q></p>
<p> </p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=3wrcwfqueue><code>3）wrc.wfQueue</code><a href=#3wrcwfqueue class=hash-link aria-label="Direct link to 3wrcwfqueue" title="Direct link to 3wrcwfqueue">​</a></h4>
<p><code>wfc.wfQueue</code>是最核心的一个消息队列，接下来我们主要学习对于该队列的业务逻辑处理。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=4utilfromunstructured><code>4）util.FromUnstructured</code><a href=#4utilfromunstructured class=hash-link aria-label="Direct link to 4utilfromunstructured" title="Direct link to 4utilfromunstructured">​</a></h4>
<p>由于我们的<code>wfc.wfInformer</code>使用的是<code>dynamicInterface</code>过滤类型，因此所有的事件对象都是<code>unstructured.Unstructured</code>对象（其实是一个<code>map[string]interface{}</code>），无法直接通过断言转换为<code>Workflow</code>对象。因此这里使用了<code>util.FromUnstructured</code>方法将<code>unstructured.Unstructured</code>对象转换为<code>Workflow</code>对象。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=5newworkflowoperationctx><code>5）newWorkflowOperationCtx</code><a href=#5newworkflowoperationctx class=hash-link aria-label="Direct link to 5newworkflowoperationctx" title="Direct link to 5newworkflowoperationctx">​</a></h4>
<p>该方法会创建核心的<code>wfOperationCtx</code>对象，该对象是在<code>Workflow</code>处理中核心的上下文流程和变量管理对象，接下来<code>wfc(WorkflowController)</code>会将业务逻辑的流程控制转交给<code>woc(wfOperationCtx)</code>来管理。我们可以这么来理解，<code>wfc</code>是一个<code>Kubernetes Controller</code>，用于<code>CRD</code>的实现，负责与<code>Kubernetes Event</code>打交道。<code>woc</code>负责内部的业务逻辑、流程、变量管理，因此<code>woc</code>是<code>Workflow</code>处理中的核心业务逻辑封装对象。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=6wocoperate><code>6）woc.operate</code><a href=#6wocoperate class=hash-link aria-label="Direct link to 6wocoperate" title="Direct link to 6wocoperate">​</a></h4>
<p>毫无疑问地，接下来的控制权转交给了<code>woc(wfOperationCtx)</code>，通过<code>woc.operate</code>进入业务逻辑处理流程。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-2_16-37-11-c9570690a4c299650a62465b2de5b914.png width=2026 height=2202 class=img_ev3q></p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-2_16-38-49-039c4ee8fa3c3e5ebb6b73fcdabef5a9.png width=2228 height=1328 class=img_ev3q></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=7wocsetexecworkflow><code>7）woc.setExecWorkflow</code><a href=#7wocsetexecworkflow class=hash-link aria-label="Direct link to 7wocsetexecworkflow" title="Direct link to 7wocsetexecworkflow">​</a></h4>
<ul>
<li>通过<code>woc.execWf</code>属性对象设置<code>woc</code>的<code>volumes</code>磁盘挂载。</li>
<li>通过<code>woc.setGlobalParameters</code>设置<code>woc</code>的<code>globalParams</code>全局变量。</li>
<li>通过<code>woc.substituteGlobalVariables</code>解析<code>woc.execWf.Spec</code>中的模板变量。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=8woccreatetemplatecontext><code>8）woc.createTemplateContext</code><a href=#8woccreatetemplatecontext class=hash-link aria-label="Direct link to 8woccreatetemplatecontext" title="Direct link to 8woccreatetemplatecontext">​</a></h4>
<p>通过<code>woc.CreateTemplateContext</code>创建<code>templateresolution.Context</code>，该对象用于<code>Workflow</code>中的<code>template</code>检索。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=9wocsubstituteparamsinvolumes><code>9）woc.substituteParamsInVolumes</code><a href=#9wocsubstituteparamsinvolumes class=hash-link aria-label="Direct link to 9wocsubstituteparamsinvolumes" title="Direct link to 9wocsubstituteparamsinvolumes">​</a></h4>
<p>通过<code>woc.substituteParamsInVolumes</code>方法解析替换<code>Volume</code>配置中的变量内容。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=10woccreatepvcs><code>10）woc.createPVCs</code><a href=#10woccreatepvcs class=hash-link aria-label="Direct link to 10woccreatepvcs" title="Direct link to 10woccreatepvcs">​</a></h4>
<p>通过<code>woc.createPVCs</code>方法根据<code>woc.execWf.Spec.VolumeClaimTemplates</code>配置创建<code>PVC</code>。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=11wocexecutetemplate><code>11）woc.executeTemplate</code><a href=#11wocexecutetemplate class=hash-link aria-label="Direct link to 11wocexecutetemplate" title="Direct link to 11wocexecutetemplate">​</a></h4>
<ul>
<li>通过<code>woc.executeTemplate</code>方法开始执行<code>Workflow</code>中的<code>Template</code>，入口为<code>woc.execWf.Spec.Entrypoint</code>。</li>
</ul>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-1_17-28-40-f486d5e170baba6230704ad705d703b4.png width=1104 height=412 class=img_ev3q></p>
<ul>
<li>内部会根据给定的<code>Entrypoint</code>先去<code>StoredTemplates</code>检索对应的<code>Template</code>对象，找到之后对该<code>Template</code>对象做深度拷贝并返回该拷贝对象。如果找不到则去<code>Workflow</code>对象中查找，并缓存、返回查找到的<code>Template</code>对象。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=12wocmergedtemplatedefaultsinto><code>12）woc.mergedTemplateDefaultsInto</code><a href=#12wocmergedtemplatedefaultsinto class=hash-link aria-label="Direct link to 12wocmergedtemplatedefaultsinto" title="Direct link to 12wocmergedtemplatedefaultsinto">​</a></h4>
<p>关于什么是<code>TemplateDefaults</code>请参考章节介绍：<a href=https://argoproj.github.io/argo-workflows/template-defaults/ target=_blank rel="noopener noreferrer">https://argoproj.github.io/argo-workflows/template-defaults/</a></p>
<p>通过<code>woc.mergedTemplateDefaultsInto</code>方法将用户配置的<code>TemplateDefaults</code>合并到当前操作的<code>Template</code>对象上。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=13commonprocessargs><code>13）common.ProcessArgs</code><a href=#13commonprocessargs class=hash-link aria-label="Direct link to 13commonprocessargs" title="Direct link to 13commonprocessargs">​</a></h4>
<p><code>common.ProcessArgs</code>方法主要用于<code>Template</code>的模板变量解析。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-2_19-43-57-f88e6ffc6b4a3a00f492ef3df7b93c40.png width=2180 height=2538 class=img_ev3q></p>
<p>注意：<code>argo</code>内部中的变量分为两种，一种是<code>Workflow</code>全局生效的变量(<code>globalParams</code>)，一种是当前<code>Template</code>生效的本地变量(<code>localParams</code>)。其中全局变量也包括开发者自定义的输入/输出变量、<code>Workflow Annotations&Labels</code>，这些变量也是能被<code>Workflow</code>全局中访问。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-2_19-35-40-7ccfcf32d1f5ef0da6371988e8f5a5ce.png width=2724 height=2242 class=img_ev3q></p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-2_19-30-46-6ce2062e4c7815d3431fc1f8f37453c5.png width=2864 height=1926 class=img_ev3q></p>
<p>在模板变量解析中，还有一个关键的点。<code>Argo</code>的模板变量是支持表达式的，表达式解析是使用 <code>github.com/antonmedv/expr</code> 组件。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_14-38-26-7dee6b55e5609d6c8a563831faa880f3.png width=1928 height=1550 class=img_ev3q></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=14processedtmplmemoize><code>14）processedTmpl.Memoize</code><a href=#14processedtmplmemoize class=hash-link aria-label="Direct link to 14processedtmplmemoize" title="Direct link to 14processedtmplmemoize">​</a></h4>
<p><code>processdTmpl.Memoize</code>配置用于开发者自定义是否缓存当前<code>Template</code>执行结果，具体介绍请参考章节：<a href=https://argoproj.github.io/argo-workflows/memoization/#using-memoization target=_blank rel="noopener noreferrer">https://argoproj.github.io/argo-workflows/memoization/#using-memoization</a></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=15processedtmplgettype><code>15）processedTmpl.GetType</code><a href=#15processedtmplgettype class=hash-link aria-label="Direct link to 15processedtmplgettype" title="Direct link to 15processedtmplgettype">​</a></h4>
<p>接下来是<code>Template</code>执行的关键地方，根据不同的<code>Template</code>类型，执行不同的操作逻辑。从流程图中可以看到，最关键的是<code>Container</code>类型，以及<code>Steps&DAG</code>类型。其中<code>Container</code>类型是所有<code>Template</code>执行的终点，也就是说<code>Template</code>执行最终是需要一个容器来实现。而<code>Steps&DAG</code>类型用于控制用户编排的<code>Template</code>流程，通过循环执行的方式，最终也会落到<code>Container</code>类型中去执行。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-2_20-29-45-b9a6a054cfe9c44905ad27b3fc1d044d.png width=3900 height=2438 class=img_ev3q></p>
<ul>
<li><strong>Suspend</strong></li>
</ul>
<p>Suspend类型的Template通过woc.executeSuspend方法实现，内部只是将当前的Template标记一下更新时间和Suspend的时间并重新丢回队列以便下一次判断。</p>
<ul>
<li><code>**Script**</code></li>
</ul>
<p><code>Script</code>类型的<code>Template</code>通过<code>woc.executeScript</code>方法实现，内部判断当前的<code>Script</code>是否有其他<code>Template</code>在使用，随后调用<code>woc.createWorkflowPod</code>创建<code>Pod</code>到<code>Kubernetes</code>中。</p>
<ul>
<li><code>**Resource**</code></li>
</ul>
<p><code>Resource</code>类型的<code>Template</code>通过<code>woc.executeResource</code>方法实现，<code>Resource</code>内容通过创建一个<code>argoexec</code>容器，并使用 <code>argoexec resource</code> 命令解析参数，容器创建通过调用<code>woc.createWorkflowPod</code>创建<code>Pod</code>到<code>Kubernetes</code>中。</p>
<ul>
<li><code>**Data**</code></li>
</ul>
<p><code>Data</code>类型的<code>Template</code>通过<code>woc.executeData</code>方法实现，<code>data</code>内容通过创建一个<code>argoexec</code>容器，并使用 <code>argoexec data</code> 命令解析参数，容器创建通过调用<code>woc.createWorkflowPod</code>创建<code>Pod</code>到<code>Kubernetes</code>中。</p>
<ul>
<li><code>**ContainerSet**</code></li>
</ul>
<p><code>ContainerSet</code>类型的<code>Template</code>通过<code>woc.executeContainerSet</code>方法实现，多个容器的创建通过调用<code>woc.createWorkflowPod</code>创建<code>Pod</code>到<code>Kubernetes</code>中。关于<code>ContainerSet</code>类型的<code>Template</code>介绍请参考：<a href=https://argoproj.github.io/argo-workflows/container-set-template/ target=_blank rel="noopener noreferrer">https://argoproj.github.io/argo-workflows/container-set-template/</a></p>
<ul>
<li><code>**Steps & DAG**</code></li>
</ul>
<p><code>Steps&DAG</code>类型的<code>Template</code>通过<code>woc.executeSteps</code>、<code>woc.executeDAG</code>方法实现，内部会对多个<code>Template</code>的流程进行控制，循环调用<code>woc.executeTemplate</code>方法执行每个<code>Template</code>。</p>
<ul>
<li><code>**Container**</code></li>
</ul>
<p>这部分是整个<code>Workflow Controller</code>调度的关键，是创建<code>Pod</code>的核心逻辑。<code>Container</code>类型的<code>Template</code>通过<code>woc.executeTemplate</code>方法实现。在该方法中，涉及到几点重要的<code>Pod</code>设置：</p>
<p>a）根据条件创建<code>Init/Wait Containers</code>，内部都是通过 <code>woc.newExecContainer </code> 创建容器，容器创建时并设置通用的环境变量以及<code>Volume</code>挂载。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_10-58-40-792a60c22cb2a146e8c9762aefc80873.png width=2284 height=1676 class=img_ev3q></p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_10-52-34-949110942b0427d6f5cb02d5e6da520d.png width=2040 height=2562 class=img_ev3q></p>
<p>b）<code>addVolumeReferences</code> 根据将开发者自定义的<code>Volume</code>，按照名称关联挂载到<code>Pod的Init/Wait/Main  Containers</code>中。</p>
<p>c）<code>addSchedulingConstraints</code> 方法根据<code>WorkflowSpec</code>的配置来设置<code>Pod</code>调度的一些调度策略，包括：<code>NodeSelector/Affinity/Tolerations/SchedulerName/PriorityClassName/Priority/HostAliases/SecurityContext</code>。</p>
<p>d）<code>woc.addInputArtifactsVolumes</code> 对于<code>artifacts</code>功能特性来说是一个很重要的方法，将<code>Artifacts</code>相关的<code>Volume</code>挂载到<code>Pod</code>中，这些<code>Volume</code>包括：<code>/argo/inputs/artifacts</code> 、 <code>/mainctrfs</code>以及开发者在配置中设置的<code>Volume</code>地址。</p>
<p>如果<code>Template</code>类型为<code>Script</code>，那么会增加挂载一个 <code>/argo/staging</code> 的<code>emptyDir</code>类型的<code>Volume</code>，用于<code>Init/Wait/``Main Containers</code>之间共享<code>Resource</code>内容。我们来看一个官方的例子<code>(scripts-bash.yaml)</code>：</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-5_19-53-5-c924a0b1bc1fa16db07fcadd5d4858df.png width=2566 height=2658 class=img_ev3q></p>
<p>在使用<code>artifacts</code>配置的时候，它会创建一个名称为 <code>inputs-artifacts</code> 的<code>emptyDir</code>类型volume供<code>Init/Wait/Main  Containers共享artifacts数据。我们来看一个官方的例子(artifacts-passing.yaml)：</code></p>
<p><code>![](/attachments/image2021-7-5_19-48-52.png)  </code></p>
<p>e）<code>addInitContainers &  addSidecars &  </code> <code>addOutputArtifactsVolumes</code> 将<code>Main Containers</code>中的<code>Volume</code>同步挂载到<code>Init/Wait Containers</code>中，以便于共享数据。从一个示例可以看到，<code>Main Containers</code>中的<code>Volume</code>在<code>Init/Wait Containers</code>中都有。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_11-15-51-e24b1dd83aafbaa72d2acd5a51533746.png width=2730 height=2702 class=img_ev3q></p>
<p>f）一些固定的环境变量设置，注意其中的<code>Template</code>环境变量设置，将整个<code>Template</code>对象转换为<code>Json</code>后塞到环境变量中，以便于后续容器读取：</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_10-23-46-a581ccbb4619991bc9dfc6f05245fafd.png width=2014 height=888 class=img_ev3q></p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_10-24-12-981af30f77711ee4a7efd43783768f2b.png width=2402 height=1144 class=img_ev3q></p>
<p>g）<code>substituePodParams</code> 最后一次变量替换，特别是来源于<code>Workflow ConfigMap</code>或者<code>Volume</code>属性的变量。</p>
<p>h）<code>kubeclientset.CoreV1.Pods.Create</code> 将之前创建的<code>Pod</code>提交到<code>Kubernetes</code>执行创建。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_10-37-11-7b706a5ef6421ad37cc74ef030a5e4e0.png width=2578 height=942 class=img_ev3q></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=五argoexec-container>五、ArgoExec Container<a href=#五argoexec-container class=hash-link aria-label="Direct link to 五、ArgoExec Container" title="Direct link to 五、ArgoExec Container">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=1核心结构>1、核心结构<a href=#1核心结构 class=hash-link aria-label="Direct link to 1、核心结构" title="Direct link to 1、核心结构">​</a></h3>
<p>整个<code>agoexec</code>逻辑中涉及到的核心数据结构如下。</p>
<table><thead><tr><th>数据结构<th>简要介绍<tbody><tr><td><code>WorkflowExecutor</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-3_10-37-11-7b706a5ef6421ad37cc74ef030a5e4e0.png width=2578 height=942 class=img_ev3q><br><br>用于<code>Init/Wait Containers</code>的运行管理核心对象。<tr><td><code>ContainerRuntimeExecutor</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-3_11-1-26-a77a3e13f6f6b64472d1a1043be086f7.png width=2082 height=1092 class=img_ev3q><br><br>如注释所示，用于与<code>Docker Container</code>进行交互的<code>API</code>接口。<tr><td><code>Artifact</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-3_11-32-4-e314ccd2a266fb81243c6bf5118b36bd.png width=2066 height=1930 class=img_ev3q><br><br><code>Artifact</code>资源管理对象。<tr><td><code>ArtifactDriver</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-3_11-27-19-6092fa30d182dc09bbc85d920e1ccf54.png width=1510 height=526 class=img_ev3q><br><br><img decoding=async loading=lazy src=/assets/images/image2021-7-3_11-31-15-8e4cc7da141d849c63f57148213f13df.png width=2112 height=698 class=img_ev3q><br><br>用于<code>Artifacts</code>的驱动管理。<code>Argo</code>默认支持多种<code>Artifacts</code>驱动。<tr><td><code>ArchiveStrategy</code><td><img decoding=async loading=lazy src=/assets/images/image2021-7-3_11-36-44-74b334246acec741448f0646bb754b31.png width=1706 height=326 class=img_ev3q><br><br><code>ArchiveStrategy</code>用以标识该<code>Artifact</code>的压缩策略。</table>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=2argoexec-init>2、<code>ArgoExec Init</code><a href=#2argoexec-init class=hash-link aria-label="Direct link to 2argoexec-init" title="Direct link to 2argoexec-init">​</a></h3>
<p>只有在<code>Template</code>类型为<code>Script</code>或者带有<code>Artifacts</code>功能时，<code>Argo Workflow Controller</code>才会为<code>Pod</code>创建<code>Init Container</code>，该<code>Container</code>使用的是<code>argoexec</code>镜像，通过 <code>argoexec init</code> 命令启动运行。<code>Init Container</code>主要的职责是将<code>Script</code>的<code>Resource</code>读取或将依赖的<code>Artifacts</code>内容拉取，保存到本地挂载的共享<code>Volume</code>上，便于后续启动的<code>Main Container</code>使用。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_11-41-5-9c5b2ed8c9b26f718307c909a764dde4.png width=2282 height=2452 class=img_ev3q></p>
<p>由于<code>Init Container</code>的执行流程比较简单，这里简单介绍一下。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=1iniexecutor--wfexecutorinit>1）<code>iniExecutor & wfExecutor.Init</code><a href=#1iniexecutor--wfexecutorinit class=hash-link aria-label="Direct link to 1iniexecutor--wfexecutorinit" title="Direct link to 1iniexecutor--wfexecutorinit">​</a></h4>
<p>首先创建<code>WorkflowExecutor</code>对象，该对象用于<code>Init/Wait Containers</code>的核心业务逻辑封装、流程控制执行。</p>
<p>在<code>WorkflowExecutor</code>对象创建时会同时创建<code>ContainerRuntimeExecutor</code>对象，用于<code>Docker Container</code>的交互，包括<code>Docker</code>终端输出读取、结果文件获取等重要操作。在默认情况下，<code>WorkflowExecutor</code>会创建一个<code>DockerExecutor</code>对象。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_11-53-2-814c8ad04ac57c69ba14edaebab6205b.png width=1570 height=684 class=img_ev3q></p>
<p>此外，大家可能会对于为何能与<code>Pod</code>内部的<code>Container</code>交互，并且如何获取到<code>Docker</code>的输出内容感觉好奇。那我们<code>describe</code>一个<code>Pod</code>来看大家也许就明白了：</p>
<p><code>![](/attachments/image2021-7-3_11-56-38.png)  </code></p>
<p>可以看到，容器中挂载了<code>docker.dock</code>文件到本地，以便本地可以通过<code>docker</code>命令与<code>docker</code>进行交互。当然<code>Init Container</code>不会直接与<code>Docker</code>交互，往往只有<code>Wait Container</code>才会，所以<code>Init Container</code>中并没有挂载该<code>docker.sock</code>文件。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=2wfexecutorstagefiles><code>2）wfExecutor.StageFiles</code><a href=#2wfexecutorstagefiles class=hash-link aria-label="Direct link to 2wfexecutorstagefiles" title="Direct link to 2wfexecutorstagefiles">​</a></h4>
<p><code>wfExecutor.StageFiles</code>方法用于将<code>Script/Resource</code>（如果有）以文件形式存写入到本地挂载的<code>Volume</code>位置，这些<code>Volume</code>是<code>Container</code>之间共享后续操作，后续<code>Main Container</code>会通过共享<code>Volume</code>访问到这些文件。需要注意的是，不同的<code>Template</code>类型，内容来源以及写入的磁盘位置会不同：</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_11-59-59-ac42773a89f0d1fa305cfd6a6d14cd02.png width=1634 height=1146 class=img_ev3q></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=3wfexecutorloadartifacts>3）<code>wfExecutor.LoadArtifacts</code><a href=#3wfexecutorloadartifacts class=hash-link aria-label="Direct link to 3wfexecutorloadartifacts" title="Direct link to 3wfexecutorloadartifacts">​</a></h4>
<p>该方法仅在使用了<code>Artifacts</code>功能的场景下有效。负责将配置的<code>Artifact</code>拉取到本地，并根据压缩策略进行解压，修改权限，以便下一步<code>Main Container</code>访问。为便于扩展，<code>Artifacts</code>使用了<code>ArtifactDrive</code>接口设计，不同类型的<code>Artifact</code>可以分开实现，并根据类型进行引入，通过接口进行使用。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=3argoexec-wait>3、<code>ArgoExec Wait</code><a href=#3argoexec-wait class=hash-link aria-label="Direct link to 3argoexec-wait" title="Direct link to 3argoexec-wait">​</a></h3>
<p>所有的<code>Argo Workflow Template</code>在执行时都会创建一个<code>Wait Container</code>，<strong>这是一个非常关键的<code>Container</code></strong>。该<code>Container</code>负责监控 <code>Main Container</code>的生命周期，在 <code>Main Container</code> 中的主要逻辑运行结束之后，负责将输出部分读取、持久化，这样 <code>Main Container</code> 就不用操心如何将该步产生的结果传到后面的步骤上的问题。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_13-54-35-493aa6b79c8f83593fb340924c8a808a.png width=2846 height=2004 class=img_ev3q></p>
<p>由于<code>Wait Container</code>的执行流程比较简单，这里简单介绍一下。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=1wfxecutorwait>1）<code>wfxecutor.Wait</code><a href=#1wfxecutorwait class=hash-link aria-label="Direct link to 1wfxecutorwait" title="Direct link to 1wfxecutorwait">​</a></h4>
<p>该方法用于等待<code>Main Container</code>完成，我们看看默认的<code>DockerExecutor</code>底层是怎么实现的：</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_13-41-38-e55b03f2a0df021a3eb464b28b6141cd.png width=1850 height=1158 class=img_ev3q></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=2wfexecutorcapturescriptresult>2）<code>wfExecutor.CaptureScriptResult</code><a href=#2wfexecutorcapturescriptresult class=hash-link aria-label="Direct link to 2wfexecutorcapturescriptresult" title="Direct link to 2wfexecutorcapturescriptresult">​</a></h4>
<p>通过捕获<code>Main Container</code>的终端输出，并保存输出结果。<strong>需要特别注意</strong>的是执行结果的大小，如果超过<code>256KB</code>将会被强行截断。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-6_14-38-0-b401a3e9531562c57f770428912c5658.png width=2316 height=1934 class=img_ev3q></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=2wfexecutorsavelogs>2）<code>wfExecutor.SaveLogs</code><a href=#2wfexecutorsavelogs class=hash-link aria-label="Direct link to 2wfexecutorsavelogs" title="Direct link to 2wfexecutorsavelogs">​</a></h4>
<p>保存日志，默认情况下会保存到<code>argo</code>自带的<code>minio</code>服务（使用<code>S3</code>通信协议）中，该日志也可以被<code>Argo Server</code>中访问展示。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_13-47-50-86a1b542ba57dc20ff86202c86593ca6.png width=1714 height=1252 class=img_ev3q></p>
<p><code>Argo</code>默认的<code>ArtifactRepository</code>：</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-5_17-48-35-c65d7d5fe19b1d339f8739ffb6c09452.png width=2818 height=1792 class=img_ev3q></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=3wfxecutorsaveparameters>3）<code>wfxecutor.SaveParameters</code><a href=#3wfxecutorsaveparameters class=hash-link aria-label="Direct link to 3wfxecutorsaveparameters" title="Direct link to 3wfxecutorsaveparameters">​</a></h4>
<p>只有在<code>Template</code>中存在<code>Outputs</code>配置时才会执行该逻辑，该方法将容器执行的结果保存到当前 <code>Template.Outputs.Parameters</code> 中。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_13-59-11-f953238551091353ee22d23b216fa785.png width=2804 height=2490 class=img_ev3q></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=3wfxecutorsaveartifacts>3）<code>wfxecutor.SaveArtifacts</code><a href=#3wfxecutorsaveartifacts class=hash-link aria-label="Direct link to 3wfxecutorsaveartifacts" title="Direct link to 3wfxecutorsaveartifacts">​</a></h4>
<p>如果<code>Template</code>存在<code>Artifacts</code>操作时，该方法用于读取<code>Main Container</code>中的<code>Artifacts</code>保存到 <code>/mainctrfs</code> 目录，并且解压（<code>untar/unzip</code>）后保存临时目录<code>/tmp/argo/outputs/artifacts</code>下，随后将临时目录中的<code>Artifacts</code>文件将上传到<code>Artifact Repository</code>中。值得注意的是：</p>
<ul>
<li><code>/mainctrfs</code> 目录是<code>Wait Container</code>与<code>Main Container</code>的共享<code>Volume</code>，因此直接文件<code>Copy</code>即可。这是内部<code>Volume</code>交互，文件都是压缩（<code>tgz</code>）过后的，无须解压。</li>
<li>临时目录 <code>/tmp/argo/outputs/artifacts</code>下的<code>Artifacts</code>文件只是用于后续的<code>ArtifactDriver</code>上传到<code>Artifact Repository</code>中，并且上传的文件内容需要实现解压（<code>untar/unzip</code>），因为压缩的机制只是<code>argo</code>内部文件交互使用，并不对外部<code>ArtifactDriver</code>通用。</li>
<li>默认的<code>ArtifactRepository</code>是<code>minio</code>，因此执行结果也会保存到<code>minio</code>服务中。</li>
</ul>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_14-17-9-9852f75b27c48e112b81b6fa8bd1d7e3.png width=2328 height=2558 class=img_ev3q></p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=4wfexecutorannotateoutputs>4）<code>wfExecutor.AnnotateOutputs</code><a href=#4wfexecutorannotateoutputs class=hash-link aria-label="Direct link to 4wfexecutorannotateoutputs" title="Direct link to 4wfexecutorannotateoutputs">​</a></h4>
<p><code>Wait Container</code>最后这一步操作很有意思。但是可能会使得<code>Metadata</code>中的<code>Annotation</code>会变得比较大。使用时需要注意，<code>Annotation</code>本身是有大小限制的，<code>Kubernetes</code>对于该项默认大小限制是<code>256KB</code>。</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_14-20-25-328dd6ee069b052193aad6242c12527e.png width=1904 height=892 class=img_ev3q></p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_14-25-18-aa13953e6a91c2f7dd3a72a7338b7e64.png width=2300 height=1290 class=img_ev3q></p>
<p>这个<code>Annotations</code>会在<code>Workflow Controller</code>调度时被自动读取出来设置到<code>Template</code>的<code>Outputs</code>属性中，这样一个<code>Template</code>执行的输出便可以被其他关联的<code>Template</code>引用到：</p>
<p><img decoding=async loading=lazy src=/assets/images/image2021-7-3_14-25-18-aa13953e6a91c2f7dd3a72a7338b7e64.png width=2300 height=1290 class=img_ev3q></p>
<p>归根到底，从底层实现来讲，多个<code>Template</code>传递流程数据的方式主要依靠<code>Annotations、Artifacts</code>及共享<code>Volume</code>。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=4argoexec其他命令>4、ArgoExec其他命令<a href=#4argoexec其他命令 class=hash-link aria-label="Direct link to 4、ArgoExec其他命令" title="Direct link to 4、ArgoExec其他命令">​</a></h3>
<p><code>ArgoExec</code>的其他命令（<code>data/resource/emissary</code>）主要用于流程调度过程中的内容解析，比较简单，这里不再做介绍，感兴趣可以看下源码。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=六常见问题>六、常见问题<a href=#六常见问题 class=hash-link aria-label="Direct link to 六、常见问题" title="Direct link to 六、常见问题">​</a></h2>
<p><code>Argo Workflow</code>的流程和主要逻辑梳理完了，接下来我们回答最开始的那几个问题。</p>
<p>由于篇幅较长，我们将问答内容迁移到了这里：<a href=/cloud-native/argo-workflow-faq>Argo Workflow常见问题</a></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href=/cloud-native/argo-workflow-introduction><div class=pagination-nav__sublabel>Previous</div><div class=pagination-nav__label>Argo Workflow介绍</div></a><a class="pagination-nav__link pagination-nav__link--next" href=/cloud-native/argo-workflow-faq><div class=pagination-nav__sublabel>Next</div><div class=pagination-nav__label>Argo Workflow常见问题</div></a></nav><div class=docusaurus-mt-lg></div></div></div><div class="col col--3"><div class=tocContainer_PXzm><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#一知识梳理 class="table-of-contents__link toc-highlight">一、知识梳理</a><li><a href=#二充满好奇 class="table-of-contents__link toc-highlight">二、充满好奇</a><li><a href=#三工程结构 class="table-of-contents__link toc-highlight">三、工程结构</a><li><a href=#四workflow-controller class="table-of-contents__link toc-highlight">四、Workflow Controller</a><ul><li><a href=#1基本架构 class="table-of-contents__link toc-highlight">1、基本架构</a><li><a href=#2重要设计 class="table-of-contents__link toc-highlight">2、重要设计</a><li><a href=#3核心结构 class="table-of-contents__link toc-highlight">3、核心结构</a><li><a href=#4核心流程 class="table-of-contents__link toc-highlight">4、核心流程</a></ul><li><a href=#五argoexec-container class="table-of-contents__link toc-highlight">五、ArgoExec Container</a><ul><li><a href=#1核心结构 class="table-of-contents__link toc-highlight">1、核心结构</a><li><a href=#2argoexec-init class="table-of-contents__link toc-highlight">2、<code>ArgoExec Init</code></a><li><a href=#3argoexec-wait class="table-of-contents__link toc-highlight">3、<code>ArgoExec Wait</code></a><li><a href=#4argoexec其他命令 class="table-of-contents__link toc-highlight">4、ArgoExec其他命令</a></ul><li><a href=#六常见问题 class="table-of-contents__link toc-highlight">六、常见问题</a></ul></div><div class=tocAdBanner_imxD></div></div></div></div></div></main></div></div></div><footer class=footer><div class="container container-fluid"><div class="footer__bottom text--center"><div class=footer__copyright>Copyright 2025 johng.cn</div></div></div></footer></div>