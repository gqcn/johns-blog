<!doctype html><html lang=en dir=ltr class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-hidden/其他文档/面试基础知识点记录" data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.6.3"><title data-rh=true>面试基础知识点记录 | John's Blog</title><meta data-rh=true name=viewport content="width=device-width,initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:url content=https://johng.cn/hidden/interview-basic-knowledge><meta data-rh=true property=og:locale content=en><meta data-rh=true name=docusaurus_locale content=en><meta data-rh=true name=docsearch:language content=en><meta data-rh=true name=keywords content=技术架构,Golang,微服务,Kubernetes,容器技术,可观测性,链路跟踪,Opentelemetry,数据库,中间件><meta data-rh=true name=docusaurus_version content=current><meta data-rh=true name=docusaurus_tag content=docs-default-current><meta data-rh=true name=docsearch:version content=current><meta data-rh=true name=docsearch:docusaurus_tag content=docs-default-current><meta data-rh=true property=og:title content="面试基础知识点记录 | John's Blog"><meta data-rh=true name=description content="mvcc与gap lock"><meta data-rh=true property=og:description content="mvcc与gap lock"><link data-rh=true rel=icon href=/img/favicon.ico><link data-rh=true rel=canonical href=https://johng.cn/hidden/interview-basic-knowledge><link data-rh=true rel=alternate href=https://johng.cn/hidden/interview-basic-knowledge hreflang=en><link data-rh=true rel=alternate href=https://johng.cn/hidden/interview-basic-knowledge hreflang=x-default><link data-rh=true rel=preconnect href=https://XGS1CPQERK-dsn.algolia.net crossorigin><link rel=search type=application/opensearchdescription+xml title="John's Blog" href=/opensearch.xml><script src=https://hm.baidu.com/hm.js?6b4ae23dc83ee5efe875b7172af6c7c1 async></script><link rel=stylesheet href=/assets/css/styles.873a270f.css><script src=/assets/js/runtime~main.d9fe5fc9.js defer></script><script src=/assets/js/main.9e331261.js defer></script><body class=navigation-with-keyboard><script>!function(){var t,e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t=null!==e?e:"light",document.documentElement.setAttribute("data-theme",t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><div role=region aria-label="Skip to main content"><a class=skipToContent_fXgn href=#__docusaurus_skipToContent_fallback>Skip to main content</a></div><nav aria-label=Main class="navbar navbar--fixed-top"><div class=navbar__inner><div class=navbar__items><button aria-label="Toggle navigation bar" aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/><b class="navbar__title text--truncate">John's Blog</b></a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/architecture>技术架构</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/management>技术管理</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/programming>开发语言</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/cloud-native>云原生</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/observability>可观测性</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/database-and-middleware>数据库与中间件</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/notes>日常笔记</a></div><div class="navbar__items navbar__items--right"><a href=https://goframe.org/ target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-goframe-link"></a><a href=https://github.com/gqcn target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class=navbarSearchContainer_Bca1><button type=button class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 20 20" aria-hidden=true><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke=currentColor fill=none fill-rule=evenodd stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>Search</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="main-wrapper mainWrapper_z2l0"><div class=docsWrapper_hBAB><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type=button></button><div class=docRoot_UBD9><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class=sidebarViewport_aRkj><div class=sidebar_njMd><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class=menu__link href=/hidden>隐藏目录</a><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/hidden/resource-collection>资源收藏</a><button aria-label="Expand sidebar category '资源收藏'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist menu__link--active" href=/hidden/other>其他文档</a><button aria-label="Collapse sidebar category '其他文档'" aria-expanded=true type=button class="clean-btn menu__caret"></button></div><ul style=display:block;overflow:visible;height:auto class=menu__list><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current=page tabindex=0 href=/hidden/interview-basic-knowledge>面试基础知识点记录</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/hidden/tencent-chai>云巢架构设计</a></ul><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/hidden/temp>临时文档</a><button aria-label="Expand sidebar category '临时文档'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div></ul></nav></div></div></aside><main class=docMainContainer_TBSr><div class="container padding-top--md padding-bottom--lg"><div class=row><div class="col docItemCol_VOVn"><div class=docItemContainer_Djhp><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label=Breadcrumbs><ul class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li class=breadcrumbs__item><a aria-label="Home page" class=breadcrumbs__link href=/><svg viewBox="0 0 24 24" class=breadcrumbHomeIcon_YNFT><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill=currentColor /></svg></a><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class=breadcrumbs__item><a class=breadcrumbs__link itemprop=item href=/hidden/other><span itemprop=name>其他文档</span></a><meta itemprop=position content=1><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class="breadcrumbs__item breadcrumbs__item--active"><span class=breadcrumbs__link itemprop=name>面试基础知识点记录</span><meta itemprop=position content=2></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type=button class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>数据库相关</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=mvcc与gap-lock>mvcc与gap lock<a href=#mvcc与gap-lock class=hash-link aria-label="Direct link to mvcc与gap lock" title="Direct link to mvcc与gap lock">​</a></h2>
<p>参考资料：</p>
<ul>
<li><a href=/database-and-middleware/mysql-innodb-mvcc>MySQL InnoDB存储引擎对MVCC的实现</a></li>
<li><a href=/database-and-middleware/mysql-lock-mechanism>MySQL锁机制</a></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=redis-的数据结构持久化方式缓存失效策略穿透与雪崩的处理方式等>redis 的数据结构，持久化方式，缓存失效策略，穿透与雪崩的处理方式等<a href=#redis-的数据结构持久化方式缓存失效策略穿透与雪崩的处理方式等 class=hash-link aria-label="Direct link to redis 的数据结构，持久化方式，缓存失效策略，穿透与雪崩的处理方式等" title="Direct link to redis 的数据结构，持久化方式，缓存失效策略，穿透与雪崩的处理方式等">​</a></h2>
<p>参考资料：</p>
<ul>
<li><a href=/database-and-middleware/redis-cache-issues>Redis缓存常见问题</a></li>
<li><a href=https://javaguide.cn/database/redis/redis-persistence.html target=_blank rel="noopener noreferrer">https://javaguide.cn/database/redis/redis-persistence.html</a></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=binlog-的几种statement-及主从同步机制>binlog 的几种statement 及主从同步机制<a href=#binlog-的几种statement-及主从同步机制 class=hash-link aria-label="Direct link to binlog 的几种statement 及主从同步机制" title="Direct link to binlog 的几种statement 及主从同步机制">​</a></h2>
<p>参考资料：<a href=/database-and-middleware/mysql-binlog-replication>浅谈 MySQL binlog 主从同步</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=mysql数据表引擎有什么>MySQL数据表引擎有什么<a href=#mysql数据表引擎有什么 class=hash-link aria-label="Direct link to MySQL数据表引擎有什么" title="Direct link to MySQL数据表引擎有什么">​</a></h2>
<p>我常用的：InnoDB、MyISAM、MEMORY、CSV。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=innodb和myisam区别>InnoDB和MyIsam区别<a href=#innodb和myisam区别 class=hash-link aria-label="Direct link to InnoDB和MyIsam区别" title="Direct link to InnoDB和MyIsam区别">​</a></h2>
<p>InnoDB <strong>支持事务、支持外键、支持崩溃修复和自增列</strong>，支持<strong>行级锁</strong>。</p>
<p>而 MyISAM 的查询效率较高、支持FULLTEXT全文索引，但不支持事务和外键，支持<strong>表级锁</strong>。</p>
<p>InnoDB 是<strong>聚簇索引</strong>，MyISAM 是<strong>非聚簇索引</strong>。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=三范式反三范式>三范式、反三范式<a href=#三范式反三范式 class=hash-link aria-label="Direct link to 三范式、反三范式" title="Direct link to 三范式、反三范式">​</a></h2>
<p>参考资料：<a href=/database-and-middleware/database-normalization>数据库三大范式与反三范式</a></p>
<ol>
<li><strong>1NF</strong>：列不可拆分，具有<strong>原子性。</strong></li>
<li><strong>2NF</strong>：满足1NF**，有主键，<strong>非主键需要</strong>完全的依赖主键**,<strong>不能依赖部分。</strong></li>
<li><strong>3NF</strong>：满足2NF，非主键<strong>需要直接依赖</strong>主键,<strong>不能传递依赖。</strong></li>
<li><strong>反三范式</strong>：就是通过该增加冗余，聚合的手段来<strong>提升性能。</strong></li>
</ol>
<h1>数据结构</h1>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=如何实现一个lru>如何实现一个LRU<a href=#如何实现一个lru class=hash-link aria-label="Direct link to 如何实现一个LRU" title="Direct link to 如何实现一个LRU">​</a></h2>
<p>参考资料：<a href=https://juejin.cn/post/7027062270702125093 target=_blank rel="noopener noreferrer">https://juejin.cn/post/7027062270702125093</a></p>
<p>实现思路: 双向链表 + 哈希表</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=b树和b树区别>B+树和B树区别<a href=#b树和b树区别 class=hash-link aria-label="Direct link to B+树和B树区别" title="Direct link to B+树和B树区别">​</a></h2>
<p>参考资料：<a href=/data-structures-and-algorithms/data-structure-tree>树（Tree）</a></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
<li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li>
</ul>
<p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>
<h1>分布式技术</h1>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=cap原理为何不能共存>CAP原理，为何不能共存<a href=#cap原理为何不能共存 class=hash-link aria-label="Direct link to CAP原理，为何不能共存" title="Direct link to CAP原理，为何不能共存">​</a></h2>
<p>参考资料：<a href=/architecture/cap-and-base>CAP原理和BASE思想</a> </p>
<blockquote>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=如果ca满足看p是否能满足>如果<strong>CA</strong>满足看P是否能满足？<a href=#如果ca满足看p是否能满足 class=hash-link aria-label="Direct link to 如果ca满足看p是否能满足" title="Direct link to 如果ca满足看p是否能满足">​</a></h3>
<p>我们来分析：当C（Consistency）一致性A（Availability）可用性都满足时会发生什么？为了保持数据的一致性，数据在各个节点间同步需要花费时间，同时保证服务可用意味着服务器的数量不能过多，因为过多就会导致数据同步时间过长，而导致超时触发熔断降级机制，这与可用性相悖。但是如果要满足容错的话就必须是多节点，而多节点意味着同步数据同步时间必定过长，这两无法做到同时满足所以就导致了情况1是无法满足。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=如果ap满足看c能否满足>如果<strong>AP</strong>满足看C能否满足？<a href=#如果ap满足看c能否满足 class=hash-link aria-label="Direct link to 如果ap满足看c能否满足" title="Direct link to 如果ap满足看c能否满足">​</a></h3>
<p>我们来分析：当A（Availability）可用性和P（Partition tolerance）分区容错性都满足的情况下会发生什么？服务器多节点部署，导致服务器数量剧增，同时需要保证服务节点可用，这就说明服务节点与节点之间的调用时间无法过长，否则就会导致服务节点不可用。如果在这种情况下，满足C（Consistency）一致性，就会出现服务器因同步数据而导致浪费大量的时间，导致服务器不可用（超过了规定时间范围），所以当AP满足时是无法同时满足C的。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=如果cp满足看a是否能满足>如果<strong>CP</strong>满足看A是否能满足？<a href=#如果cp满足看a是否能满足 class=hash-link aria-label="Direct link to 如果cp满足看a是否能满足" title="Direct link to 如果cp满足看a是否能满足">​</a></h3>
<p>我们来分析：当C（Consistency）一致性和P（Partition tolerance）分区容错性都满足时，这个时候的服务器情况是怎么样的？必定是数量多并且为了保证数据同步大量的服务器节点会进入“超长待机”状态，此时如果再让服务满足A（可用性）的话，就会出现大部分的服务节点不可用，线程池被挤爆，然后整个项目宕机。所以情况3是无法满足的。</p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=raft选举流程>RAFT选举流程<a href=#raft选举流程 class=hash-link aria-label="Direct link to RAFT选举流程" title="Direct link to RAFT选举流程">​</a></h2>
<p>参考资料：<a href=/database-and-middleware/distributed-system-raft>分布式系统的Raft算法</a></p>
<p>在极简的思维下，一个最小的 Raft 民主集群需要三个参与者（如下图：A、B、C），这样才可能投出多数票。初始状态 ABC 都是 Follower，然后发起选举这时有三种可能情形发生。下图中前二种都能选出 Leader，第三种则表明本轮投票无效（Split Votes），每方都投给了自己，结果没有任何一方获得多数票。之后每个参与方随机休息一阵（Election Timeout）重新发起投票直到一方获得多数票。<strong>这里的关键就是随机 timeout，最先从 timeout 中恢复发起投票的一方向还在 timeout 中的另外两方请求投票，这时它们就只能投给对方了，很快达成一致</strong>。</p>
<p>选出 Leader 后，Leader 通过定期向所有 Follower 发送心跳信息维持其统治。若 Follower 一段时间未收到 Leader 的心跳则认为 Leader 可能已经挂了再次发起选主过程。</p>
<p><img decoding=async loading=lazy src=/assets/images/auto-815275-20160301175349689-522400583-98ceb5596d3d5bd6e09cde57fb16a146.png width=1280 height=1145 class=img_ev3q></p>
<h1>网络通信</h1>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=自底向上介绍7层以及分别有什么协议>自底向上介绍7层以及分别有什么协议<a href=#自底向上介绍7层以及分别有什么协议 class=hash-link aria-label="Direct link to 自底向上介绍7层以及分别有什么协议" title="Direct link to 自底向上介绍7层以及分别有什么协议">​</a></h2>
<p> 参考资料：<a href=/operating-systems-and-networks/network-layer-models>OSI七层模型与TCP/IP五层模型</a></p>
<p>应用层、表示层、会话层、传输层、网络层、数据量路层、物理层。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=传输层tcp和udp区别>传输层TCP和UDP区别<a href=#传输层tcp和udp区别 class=hash-link aria-label="Direct link to 传输层TCP和UDP区别" title="Direct link to 传输层TCP和UDP区别">​</a></h2>
<p><strong>TCP</strong>是面向连接的协议，在收发数据前必须和对方建立可靠的连接，建立连接的3次握手、断开连接的4次挥手，为数据<strong>传输</strong>打下可靠基础;<strong>UDP</strong>是一个面向无连接的协议，数据<strong>传输</strong>前，源端和终端不建立连接，发送端尽可能快的将数据扔到网络上，接收端从消息队列中读取消息段。</p>
<table><thead><tr><th>特性<th>TCP<th>UDP<tbody><tr><td><strong>连接性</strong><td>面向连接<td>无连接<tr><td><strong>可靠性</strong><td>可靠<td>不可靠<tr><td><strong>有序性</strong><td>有序<td>无序<tr><td><strong>有界性</strong><td>有界<td>无界<tr><td><strong>拥塞控制</strong><td>有<td>无<tr><td><strong>传输速度</strong><td>慢<td>快<tr><td><strong>量级</strong><td>重量级<td>轻量级<tr><td><strong>头部大小</strong><td>大<td>小</table>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=tcp和udp可以对同一端口同时使用吗>TCP和UDP可以对同一端口同时使用吗<a href=#tcp和udp可以对同一端口同时使用吗 class=hash-link aria-label="Direct link to TCP和UDP可以对同一端口同时使用吗" title="Direct link to TCP和UDP可以对同一端口同时使用吗">​</a></h2>
<p>TCP、UDP可以同时绑定同一个端口，但是同一个端口在同一时刻不可以被同一种网络协议重复绑定。<br>
<!-- -->原因如下：</p>
<ol>
<li>TCP的端口不是物理概念，仅仅是协议栈中的两个字节。</li>
<li>TCP和UDP的端口完全没有任何关系，完全有可能又有一种XXP基于IP，也有端口的概念，这是完全可能的。</li>
<li>TCP和UDP传输协议监听同一个端口后，接收数据互不影响，不冲突。因为数据接收时时根据 <strong>五元组(传输协议，源IP，目的IP，源端口，目的端口)</strong> 判断接受者的。</li>
</ol>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=几种io模型selectpollepollkqueue的区别>几种IO模型select、poll、epoll、kqueue的区别<a href=#几种io模型selectpollepollkqueue的区别 class=hash-link aria-label="Direct link to 几种IO模型select、poll、epoll、kqueue的区别" title="Direct link to 几种IO模型select、poll、epoll、kqueue的区别">​</a></h2>
<p>参考资料：<a href=/operating-systems-and-networks/io-multiplexing-models>select,poll,epoll,kqueue IO多路复用模型归纳总结区分</a></p>
<table><thead><tr><th><th><tbody><tr><td><strong>select</strong><td>select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：<br><br>*   单个进程可监视的fd数量被限制<br>*   需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大<br>*   对socket进行扫描时是<strong>线性扫描</strong><tr><td><strong>poll</strong><td>*   <strong>poll本质上和select没有区别</strong>，它将用户传入的数组拷贝到<strong>内核空间</strong>，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。<br>*   它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。<br>*   poll还有一个特点是“<strong>水平触发</strong>”：如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。<tr><td><strong>epoll</strong><td>*   epoll支持<strong>水平触发</strong>和<strong>边缘触发</strong>，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就需态，并且只会通知一次。<br>*   在前面说到的复制问题上，epoll使用mmap减少复制开销。<br>*   还有一个特点是，<strong>epoll使用“事件”的就绪通知方式</strong>，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。<br>*   epoll 使用红黑树 (RB-tree) 数据结构来跟踪当前正在监视的所有文件描述符。<tr><td><strong>kqueue  <br></strong><td>*   kqueue和epoll一样，都是用来替换select和poll的。<strong>不同的是kqueue被用在FreeBSD,NetBSD, OpenBSD, DragonFly BSD 和 macOS中</strong>。<br>*   kqueue 不仅能够处理文件描述符事件，还可以用于各种其他通知，例如文件修改监视、信号、异步 I/O 事件 (AIO)、子进程状态更改监视和支持纳秒级分辨率的计时器，此外kqueue提供了一种方式除了内核提供的事件之外，还可以使用用户定义的事件。</table>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=tcp流量控制和滑动窗口>TCP流量控制和滑动窗口<a href=#tcp流量控制和滑动窗口 class=hash-link aria-label="Direct link to TCP流量控制和滑动窗口" title="Direct link to TCP流量控制和滑动窗口">​</a></h2>
<p>参考资料：<a href=https://xiaolincoding.com/network/3_tcp/tcp_feature.html target=_blank rel="noopener noreferrer">https://xiaolincoding.com/network/3_tcp/tcp_feature.html</a></p>
<p><strong>滑动窗口</strong></p>
<p>我们都知道 TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。这个模式就有点像我和你面对面聊天，你一句我一句。但这种方式的缺点是效率比较低的。如果你说完一句话，我在处理其他事情，没有及时回复你，那你不是要干等着我做完其他事情后，我回复你，你才能说下一句话，很显然这不现实。所以，这样的传输方式有一个缺点：数据包的<strong>往返时间越长，通信的效率就越低</strong>。</p>
<p>为解决这个问题，TCP 引入了<strong>窗口</strong>这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。那么有了窗口，就可以指定窗口大小，窗口大小就是指<strong>无需等待确认应答，而可以继续发送数据的最大值</strong>。窗口的实现实际上是操作系统开辟的一个缓存空间，发送方主机在等到确认应答返回之前，必须在缓冲区中保留已发送的数据。如果按期收到确认应答，此时数据就可以从缓存区清除。</p>
<p>假设窗口大小为 <code>3</code> 个 TCP 段，那么发送方就可以「连续发送」 <code>3</code> 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。</p>
<blockquote>
<p>窗口大小由哪一方决定？</p>
</blockquote>
<p>TCP 头里有一个字段叫 <code>Window</code>，也就是窗口大小。**这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。**所以，通常窗口的大小是由接收方的窗口大小来决定的。发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据。</p>
<p><strong>流量控制</strong></p>
<p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=websocket的工作机制>Websocket的工作机制<a href=#websocket的工作机制 class=hash-link aria-label="Direct link to Websocket的工作机制" title="Direct link to Websocket的工作机制">​</a></h2>
<p>参考资料：<a href=/operating-systems-and-networks/websocket-protocol>WebSocket的原理</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=https如何加密的>HTTPS如何加密的<a href=#https如何加密的 class=hash-link aria-label="Direct link to HTTPS如何加密的" title="Direct link to HTTPS如何加密的">​</a></h2>
<p>参考资料：<a href=https://xiaolincoding.com/network/2_http/https_rsa.html target=_blank rel="noopener noreferrer">https://xiaolincoding.com/network/2_http/https_rsa.html</a></p>
<p>传统的 TLS 握手基本都是使用 RSA 算法来实现密钥交换的，在将 TLS 证书部署服务端时，证书文件其实就是服务端的公钥，会在 TLS 握手阶段传递给客户端，而服务端的私钥则一直留在服务端，一定要确保私钥不能被窃取。</p>
<p>在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。<strong>根据非对称加密算法，公钥加密的消息仅能通过私钥解密</strong>，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=数组和链表的区别>数组和链表的区别<a href=#数组和链表的区别 class=hash-link aria-label="Direct link to 数组和链表的区别" title="Direct link to 数组和链表的区别">​</a></h2>
<p>参考资料：<a href=https://docs.pingcode.com/ask/21488.html target=_blank rel="noopener noreferrer">https://docs.pingcode.com/ask/21488.html</a></p>
<ol>
<li>存储空间不同</li>
<li>访问速度不同</li>
<li>插入和删除操作不同</li>
<li>适用场景不同</li>
</ol>
<h1>系统基础</h1>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=进程和线程区别>进程和线程区别<a href=#进程和线程区别 class=hash-link aria-label="Direct link to 进程和线程区别" title="Direct link to 进程和线程区别">​</a></h2>
<p>参考资料：</p>
<ul>
<li><a href=https://blog.csdn.net/ThinkWon/article/details/102021274 target=_blank rel="noopener noreferrer">https://blog.csdn.net/ThinkWon/article/details/102021274</a></li>
<li><a href=https://cloud.tencent.com/developer/article/1688297 target=_blank rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1688297</a></li>
</ul>
<p><strong>根本区别</strong>：进程是操作<strong>系统资源分配</strong>的基本单位；而线程是<strong>处理器任务调度和执行</strong>的基本单位。</p>
<p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p>
<p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p>
<p><strong>内存分配</strong>：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的。</p>
<p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<p><strong>执行过程</strong>：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=线程死锁条件>线程死锁条件<a href=#线程死锁条件 class=hash-link aria-label="Direct link to 线程死锁条件" title="Direct link to 线程死锁条件">​</a></h2>
<p>参考资料：<a href=https://cloud.tencent.com/developer/article/1493418 target=_blank rel="noopener noreferrer">https://cloud.tencent.com/developer/article/1493418</a></p>
<ul>
<li><strong>互斥条件</strong>：一个资源每次只能被一个进程使用。</li>
<li><strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>：进程已获得的资源，在没使用完之前，不能强行剥夺。</li>
<li><strong>循环等待条件</strong>：多个进程之间形成一种互相循环等待资源的关系。</li>
</ul>
<p>两个线程各自持有一个无法共享(**互斥条件)**的资源，并且他们都需要获取（<strong>请求与保持条件</strong>）对方现在持有的资源才能进行下一步，但是他们又必须等对方释放了才能去获取(<strong>不可剥夺条件</strong>)，于是A等待B，B也在等待A（<strong>循环等待条件</strong>）。如此这般，死锁就产生了。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=进程间通信方式>进程间通信方式<a href=#进程间通信方式 class=hash-link aria-label="Direct link to 进程间通信方式" title="Direct link to 进程间通信方式">​</a></h2>
<p>参考资料：<a href=https://www.cnblogs.com/LUO77/p/5816326.html target=_blank rel="noopener noreferrer">https://www.cnblogs.com/LUO77/p/5816326.html</a></p>
<ol>
<li>
<p><strong>管道Pipe</strong>：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
</li>
<li>
<p><strong>命名管道FIFO</strong>：命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
</li>
<li>
<p><strong>消息队列MessageQueue</strong>：消息队列是由消息的链表，<strong>存放在内核中</strong>并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
</li>
<li>
<p><strong>共享内存SharedMemory</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
</li>
<li>
<p><strong>信号量Semaphore</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
</li>
<li>
<p><strong>套接字Socket</strong>：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。</p>
</li>
<li>
<p><strong>信号Signal</strong>： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
</li>
</ol></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href=/hidden/other><div class=pagination-nav__sublabel>Previous</div><div class=pagination-nav__label>其他文档</div></a><a class="pagination-nav__link pagination-nav__link--next" href=/hidden/tencent-chai><div class=pagination-nav__sublabel>Next</div><div class=pagination-nav__label>云巢架构设计</div></a></nav><div class=docusaurus-mt-lg></div></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#mvcc与gap-lock class="table-of-contents__link toc-highlight">mvcc与gap lock</a><li><a href=#redis-的数据结构持久化方式缓存失效策略穿透与雪崩的处理方式等 class="table-of-contents__link toc-highlight">redis 的数据结构，持久化方式，缓存失效策略，穿透与雪崩的处理方式等</a><li><a href=#binlog-的几种statement-及主从同步机制 class="table-of-contents__link toc-highlight">binlog 的几种statement 及主从同步机制</a><li><a href=#mysql数据表引擎有什么 class="table-of-contents__link toc-highlight">MySQL数据表引擎有什么</a><li><a href=#innodb和myisam区别 class="table-of-contents__link toc-highlight">InnoDB和MyIsam区别</a><li><a href=#三范式反三范式 class="table-of-contents__link toc-highlight">三范式、反三范式</a><li><a href=#如何实现一个lru class="table-of-contents__link toc-highlight">如何实现一个LRU</a><li><a href=#b树和b树区别 class="table-of-contents__link toc-highlight">B+树和B树区别</a><li><a href=#cap原理为何不能共存 class="table-of-contents__link toc-highlight">CAP原理，为何不能共存</a><ul><li><a href=#如果ca满足看p是否能满足 class="table-of-contents__link toc-highlight">如果<strong>CA</strong>满足看P是否能满足？</a><li><a href=#如果ap满足看c能否满足 class="table-of-contents__link toc-highlight">如果<strong>AP</strong>满足看C能否满足？</a><li><a href=#如果cp满足看a是否能满足 class="table-of-contents__link toc-highlight">如果<strong>CP</strong>满足看A是否能满足？</a></ul><li><a href=#raft选举流程 class="table-of-contents__link toc-highlight">RAFT选举流程</a><li><a href=#自底向上介绍7层以及分别有什么协议 class="table-of-contents__link toc-highlight">自底向上介绍7层以及分别有什么协议</a><li><a href=#传输层tcp和udp区别 class="table-of-contents__link toc-highlight">传输层TCP和UDP区别</a><li><a href=#tcp和udp可以对同一端口同时使用吗 class="table-of-contents__link toc-highlight">TCP和UDP可以对同一端口同时使用吗</a><li><a href=#几种io模型selectpollepollkqueue的区别 class="table-of-contents__link toc-highlight">几种IO模型select、poll、epoll、kqueue的区别</a><li><a href=#tcp流量控制和滑动窗口 class="table-of-contents__link toc-highlight">TCP流量控制和滑动窗口</a><li><a href=#websocket的工作机制 class="table-of-contents__link toc-highlight">Websocket的工作机制</a><li><a href=#https如何加密的 class="table-of-contents__link toc-highlight">HTTPS如何加密的</a><li><a href=#数组和链表的区别 class="table-of-contents__link toc-highlight">数组和链表的区别</a><li><a href=#进程和线程区别 class="table-of-contents__link toc-highlight">进程和线程区别</a><li><a href=#线程死锁条件 class="table-of-contents__link toc-highlight">线程死锁条件</a><li><a href=#进程间通信方式 class="table-of-contents__link toc-highlight">进程间通信方式</a></ul></div></div></div></div></main></div></div></div><footer class=footer><div class="container container-fluid"><div class="footer__bottom text--center"><div class=footer__copyright>Copyright 2025 johng.cn</div></div></div></footer></div>