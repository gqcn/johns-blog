<!doctype html><html lang=en dir=ltr class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-docs/数据库与中间件/Redis/Redis缓存常见问题" data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.6.3"><title data-rh=true>Redis缓存常见问题 | John's Blog</title><meta data-rh=true name=viewport content="width=device-width,initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:url content=https://johng.cn/database-and-middleware/redis-cache-issues><meta data-rh=true property=og:locale content=en><meta data-rh=true name=docusaurus_locale content=en><meta data-rh=true name=docsearch:language content=en><meta data-rh=true name=author content="John Guo"><meta data-rh=true property=og:image content=https://johng.cn/img/favicon.png><meta data-rh=true name=docusaurus_version content=current><meta data-rh=true name=docusaurus_tag content=docs-default-current><meta data-rh=true name=docsearch:version content=current><meta data-rh=true name=docsearch:docusaurus_tag content=docs-default-current><meta data-rh=true property=og:title content="Redis缓存常见问题 | John's Blog"><meta data-rh=true name=description content="探讨 Redis 缓存使用中的常见问题及其解决方案，包括缓存穿透、击穿、雪崩等问题的分析和处理"><meta data-rh=true property=og:description content="探讨 Redis 缓存使用中的常见问题及其解决方案，包括缓存穿透、击穿、雪崩等问题的分析和处理"><meta data-rh=true name=keywords content=Redis,缓存,缓存穿透,缓存击穿,缓存雪崩,性能优化,问题排查><link data-rh=true rel=icon href=/img/favicon.ico><link data-rh=true rel=canonical href=https://johng.cn/database-and-middleware/redis-cache-issues><link data-rh=true rel=alternate href=https://johng.cn/database-and-middleware/redis-cache-issues hreflang=en><link data-rh=true rel=alternate href=https://johng.cn/database-and-middleware/redis-cache-issues hreflang=x-default><link data-rh=true rel=preconnect href=https://XGS1CPQERK-dsn.algolia.net crossorigin><link rel=alternate type=application/rss+xml href=/blog/rss.xml title="John's Blog RSS Feed"><link rel=alternate type=application/atom+xml href=/blog/atom.xml title="John's Blog Atom Feed"><link rel=search type=application/opensearchdescription+xml title="John's Blog" href=/opensearch.xml><script src=https://hm.baidu.com/hm.js?6b4ae23dc83ee5efe875b7172af6c7c1 async></script><link rel=stylesheet href=/assets/css/styles.2f56d3c4.css><script src=/assets/js/runtime~main.3251fb5b.js defer></script><script src=/assets/js/main.bf594746.js defer></script><body class=navigation-with-keyboard><script>!function(){var t,e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t=null!==e?e:"light",document.documentElement.setAttribute("data-theme",t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><div role=region aria-label="Skip to main content"><a class=skipToContent_fXgn href=#__docusaurus_skipToContent_fallback>Skip to main content</a></div><nav aria-label=Main class="navbar navbar--fixed-top"><div class=navbar__inner><div class=navbar__items><button aria-label="Toggle navigation bar" aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/><b class="navbar__title text--truncate">John's Blog</b></a><a class="navbar__item navbar__link" href=/ai>AI技术</a><a class="navbar__item navbar__link" href=/cloud-native>云原生</a><a class="navbar__item navbar__link" href=/notes>日常笔记</a><a class="navbar__item navbar__link" href=/programming>开发语言</a><a class="navbar__item navbar__link" href=/architecture>技术架构</a><a class="navbar__item navbar__link" href=/observability>可观测性</a><a aria-current=page class="navbar__item navbar__link navbar__link--active" href=/database-and-middleware>数据库与中间件</a><a class="navbar__item navbar__link" href=/life>生活笔记</a></div><div class="navbar__items navbar__items--right"><a class="navbar__item navbar__link" href=/aboutme>关于我</a><a class="navbar__item navbar__link" href=/blog>博客</a><a href=https://goframe.org/ target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-goframe-link"></a><a href=https://github.com/gqcn target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class=navbarSearchContainer_Bca1><button type=button class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 20 20" aria-hidden=true><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke=currentColor fill=none fill-rule=evenodd stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>Search</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="main-wrapper mainWrapper_z2l0"><div class=docsWrapper_hBAB><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type=button></button><div class=docRoot_UBD9><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class=sidebarViewport_aRkj><div class=sidebar_njMd><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/ai>AI技术</a><button aria-label="Expand sidebar category 'AI技术'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/cloud-native>云原生</a><button aria-label="Expand sidebar category '云原生'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/notes>日常笔记</a><button aria-label="Expand sidebar category '日常笔记'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/programming>开发语言</a><button aria-label="Expand sidebar category '开发语言'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/architecture>技术架构</a><button aria-label="Expand sidebar category '技术架构'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/management>技术管理</a><button aria-label="Expand sidebar category '技术管理'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/observability>可观测性</a><button aria-label="Expand sidebar category '可观测性'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist menu__link--active" href=/database-and-middleware>数据库与中间件</a><button aria-label="Collapse sidebar category '数据库与中间件'" aria-expanded=true type=button class="clean-btn menu__caret"></button></div><ul style=display:block;overflow:visible;height:auto class=menu__list><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" tabindex=0 href=/database-and-middleware/mysql>MySQL</a><button aria-label="Expand sidebar category 'MySQL'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist menu__link--active" tabindex=0 href=/database-and-middleware/redis>Redis</a><button aria-label="Collapse sidebar category 'Redis'" aria-expanded=true type=button class="clean-btn menu__caret"></button></div><ul style=display:block;overflow:visible;height:auto class=menu__list><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/database-and-middleware/redis-skiplist-sorted-set>Redis 为什么用跳表实现有序集合</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/database-and-middleware/redis-sentinel>Redis哨兵机制</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current=page tabindex=0 href=/database-and-middleware/redis-cache-issues>Redis缓存常见问题</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/database-and-middleware/redis-stream>Redis Stream简介</a></ul><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" tabindex=0 href=/database-and-middleware/etcd>Etcd</a><button aria-label="Expand sidebar category 'Etcd'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/database-and-middleware/database-normalization>数据库三大范式与反三范式</a></ul><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/operating-systems-and-networks>操作系统和网络</a><button aria-label="Expand sidebar category '操作系统和网络'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/life>生活笔记</a><button aria-label="Expand sidebar category '生活笔记'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div></ul></nav></div></div></aside><main class=docMainContainer_TBSr><div class="container padding-top--md padding-bottom--lg"><div class=row><div class="col docItemCol_VOVn"><div class=docItemContainer_Djhp><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label=Breadcrumbs><ul class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li class=breadcrumbs__item><a aria-label="Home page" class=breadcrumbs__link href=/><svg viewBox="0 0 24 24" class=breadcrumbHomeIcon_YNFT><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill=currentColor /></svg></a><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class=breadcrumbs__item><a class=breadcrumbs__link itemprop=item href=/database-and-middleware><span itemprop=name>数据库与中间件</span></a><meta itemprop=position content=1><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class=breadcrumbs__item><a class=breadcrumbs__link itemprop=item href=/database-and-middleware/redis><span itemprop=name>Redis</span></a><meta itemprop=position content=2><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class="breadcrumbs__item breadcrumbs__item--active"><span class=breadcrumbs__link itemprop=name>Redis缓存常见问题</span><meta itemprop=position content=3></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type=button class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h2 class="anchor anchorWithStickyNavbar_LWe7" id=缓存穿透>缓存穿透<a href=#缓存穿透 class=hash-link aria-label="Direct link to 缓存穿透" title="Direct link to 缓存穿透">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=什么是缓存穿透>什么是缓存穿透？<a href=#什么是缓存穿透 class=hash-link aria-label="Direct link to 什么是缓存穿透？" title="Direct link to 什么是缓存穿透？">​</a></h3>
<p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=有哪些解决办法>有哪些解决办法？<a href=#有哪些解决办法 class=hash-link aria-label="Direct link to 有哪些解决办法？" title="Direct link to 有哪些解决办法？">​</a></h3>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<h4><div style='background-size:cover;background-repeat:no-repeat;position:relative;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAUCAIAAAA7jDsBAAAACXBIWXMAAAsTAAALEwEAmpwYAAABvUlEQVR4nG2STWsTURSG768Q/4cu3BQXrt259S+4UNBNFwrFTRaCIihYxaqgq4BSiiKlatukaSlpNW2SyeSr08l8JDOTmbn3nntn7j3SRGoogYfDgWdxDrwvYSibDit+26maQaozhpwhnEMYiuYAPhQ3dutuqvOLmmpOMWvbVsApQzHr2FQLlH33JOAhn6sjEe/93q+Zx/M1oLT8QSzTuRoE6o7dHwvKMeMoJzODyU4oBKO1wsGru4PiI+ob4zgIh3YUOIFvJ2OfcGobD68/WLhUuXdVNH70SuXW96+djfXa2qq7VyaQp+HBl88rT6ytjxnzAHPQMIUpIJFMQpVZQ89hyYiPU8UowjlkELlmv1Wt7f+pHxr91r//NUwhXIsYxWG36fJIopKoAZU4QwtUxObh7U/LC/fv3Hr7vHpqhmbDM+vDdsMzjrx2g1g8vPnm2eVrV248fbzba3a3f3V2tnuVUmvrp1kpkUSxqtNd3Vwvd+tRzhTi5ITKUEtUhGlARG/og5SA8izAGQjNaXZi2uVNahxxmVzIlIh0FBYKxuKis7QkrA5FxfT/RhDgEbx/F798wV4vg3/KMJ/VfwHcahzOcDFa5QAAAABJRU5ErkJggg==")'><svg style=width:100%;height:auto;max-width:100%;margin-bottom:-4px width=365 height=722 /><noscript><img style=width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0 src=/assets/ideal-img/redis-cache-penetration.000218d.365.png srcset="/assets/ideal-img/redis-cache-penetration.000218d.365.png 365w" alt="" width=365 height=722></noscript></div></h4>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=1缓存无效-key><strong>1）缓存无效 key</strong><a href=#1缓存无效-key class=hash-link aria-label="Direct link to 1缓存无效-key" title="Direct link to 1缓存无效-key">​</a></h4>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的：<code>表名:列名:主键名:主键值</code> 。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=2布隆过滤器><strong>2）布隆过滤器</strong><a href=#2布隆过滤器 class=hash-link aria-label="Direct link to 2布隆过滤器" title="Direct link to 2布隆过滤器">​</a></h4>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们可以把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于我们平时常用的 List、Map、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p>
<div style='background-size:cover;background-repeat:no-repeat;position:relative;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAADCAIAAAAlXwkiAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAVklEQVR4nCXISQ6AIAwAQP7/RxOhglGjyNaWGqwH5zgGlVG5vVwHbqWc1OrAP1HZiA7Rl59EtHM/upyIoUkuQjTErDX4tECcfbI+WYizuyYXLdywZPgAsC5VCD3SjJ8AAAAASUVORK5CYII=")'><svg style=width:100%;height:auto;max-width:100%;margin-bottom:-4px width=640 height=197 /><noscript><img style=width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0 src=/assets/ideal-img/bloom-filter-simple-schematic-diagram.fd16658.640.png srcset="/assets/ideal-img/bloom-filter-simple-schematic-diagram.fd16658.640.png 640w,/assets/ideal-img/bloom-filter-simple-schematic-diagram.bdc14c6.781.png 781w" alt="" width=640 height=197></noscript></div>
<p>Bloom Filter 会使用一个较大的 bit 数组来保存所有的数据，数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1（代表 false 或者 true），这也是 Bloom Filter 节省内存的核心所在。这样来算的话，申请一个 100w 个元素的位数组只占用 1000000Bit / 8 = 125000 Byte = 125000/1024 KB ≈ 122KB 的空间。</p>
<div style='background-size:cover;background-repeat:no-repeat;position:relative;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAABCAIAAABol6gpAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIUlEQVR4nGN49vn58y8g9Ozzszsv79x9dQ/EBQs+/fQUAKdRG0seqGIdAAAAAElFTkSuQmCC")'><svg style=width:100%;height:auto;max-width:100%;margin-bottom:-4px width=640 height=75 /><noscript><img style=width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0 src=/assets/ideal-img/bloom-filter-bit-table.c2ab428.640.png srcset="/assets/ideal-img/bloom-filter-bit-table.c2ab428.640.png 640w,/assets/ideal-img/bloom-filter-bit-table.bc57059.781.png 781w" alt="" width=640 height=75></noscript></div>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<div style='background-size:cover;background-repeat:no-repeat;position:relative;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAMCAIAAADUCbv3AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAxUlEQVR4nG2Qy2rDMBBF/f+f1kUh3bgprkmdF45TgZxYimbuXBXFNKahZ3c582Cmyr+QzDkPw+Cce8Qq/2UcR+/9Iz7rEMM0TQD+112779p9SgJARJ717qs/boecs4jEGBcNVQXieAq+J2lmy3CSqiDzebM6b1bMVFEAFUmYhYv73r4b5H5OwcyK1gKu7nj4eNEUbknmsTBTRZVSmvOMqs4PWbpZKOtJXkNKWqpvgktIVV3XTdPMrQK+fQ7twati3bnXdf8DxK1eFHSzVqgAAAAASUVORK5CYII=")'><svg style=width:100%;height:auto;max-width:100%;margin-bottom:-4px width=626 height=758 /><noscript><img style=width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0 src=/assets/ideal-img/redis-cache-penetration-bloom-filter.976e8fa.626.png srcset="/assets/ideal-img/redis-cache-penetration-bloom-filter.976e8fa.626.png 626w" alt="" width=626 height=758></noscript></div>
<p>更多关于布隆过滤器的详细介绍可以看看我的这篇原创：<a href=https://javaguide.cn/cs-basics/data-structure/bloom-filter.html target=_blank rel="noopener noreferrer">不了解布隆过滤器？一文给你整的明明白白！</a>，强烈推荐。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=3接口限流><strong>3）接口限流</strong><a href=#3接口限流 class=hash-link aria-label="Direct link to 3接口限流" title="Direct link to 3接口限流">​</a></h4>
<p><strong>根据用户或者 IP 对接口进行限流</strong>，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。</p>
<p>后面提到的缓存击穿和雪崩都可以配合接口限流来解决，毕竟这些问题的关键都是有很多请求落到了数据库上造成数据库压力过大。</p>
<p>限流的具体方案可以参考这篇文章：<a href=https://javaguide.cn/high-availability/limit-request.html target=_blank rel="noopener noreferrer">服务限流详解</a>。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=缓存击穿>缓存击穿<a href=#缓存击穿 class=hash-link aria-label="Direct link to 缓存击穿" title="Direct link to 缓存击穿">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=什么是缓存击穿>什么是缓存击穿？<a href=#什么是缓存击穿 class=hash-link aria-label="Direct link to 什么是缓存击穿？" title="Direct link to 什么是缓存击穿？">​</a></h3>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<div style='background-size:cover;background-repeat:no-repeat;position:relative;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAATCAIAAAAmiQu5AAAACXBIWXMAAAsTAAALEwEAmpwYAAABsklEQVR4nG2RPW/TUBSG7w9hZOA/IFViqARrBwYkVtaOlbp1iDrCQBfoiCgFCVUVA1JFJUS/TByI07qJY5PETuw4uY5DTO53fA9yQlEFlR69yyO9enUOoiCdiO5+OKo08VQrCowC/wuiINqJeP/xuOphAv9popkA1ccDIhkDcd3RhabAm4Ebpv2b9URk1brV9N2btYA8SoZEcgaC5HQOK1KzQnM1abVq40mfAReQS9ACtALNQSFC8eDV6pfSQ//lExrbkee0K2eB9c01TpLgB2I0djcfrC7dOlu7K3tm62v5+O2Oub93+m4XNy4Q14wljlX+NO5aakZkUT4TMFOQc5AIT0d+OrQ7nhMGAY4yNSXAiWYL0Iikw3HccO0gbEWjfianVM9nXy3n7i98cG7WcJdomYOWc1SROerS9P72s9uPVpaeb5Y7jdg0OsZJzzTap0e97yaK+M/HO9t3lu+tvHhaizvYscP6eezYvUtr4NWLsyQyqwdemA2p5otm8SdzRPVMA4R4QKXkAFcXnVNMu6hmnw/9/b308IBWDPbPS8ZvXjfX1/1Sqbuxgbe2BHByTf8GOiX9ylNhF+EAAAAASUVORK5CYII=")'><svg style=width:100%;height:auto;max-width:100%;margin-bottom:-4px width=365 height=702 /><noscript><img style=width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0 src=/assets/ideal-img/redis-cache-breakdown.77dbcb2.365.png srcset="/assets/ideal-img/redis-cache-breakdown.77dbcb2.365.png 365w" alt="" width=365 height=702></noscript></div>
<p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=有哪些解决办法-1>有哪些解决办法？<a href=#有哪些解决办法-1 class=hash-link aria-label="Direct link to 有哪些解决办法？" title="Direct link to 有哪些解决办法？">​</a></h3>
<ol>
<li><strong>永不过期</strong>（不推荐）：设置热点数据永不过期或者过期时间比较长。</li>
<li><strong>提前预热</strong>（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li><strong>加锁</strong>（看情况）：<strong>在缓存失效后，通过设置互斥锁确保只有一个请求去查询数据库并更新缓存。</strong></li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=缓存穿透和缓存击穿有什么区别>缓存穿透和缓存击穿有什么区别？<a href=#缓存穿透和缓存击穿有什么区别 class=hash-link aria-label="Direct link to 缓存穿透和缓存击穿有什么区别？" title="Direct link to 缓存穿透和缓存击穿有什么区别？">​</a></h3>
<p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=缓存雪崩>缓存雪崩<a href=#缓存雪崩 class=hash-link aria-label="Direct link to 缓存雪崩" title="Direct link to 缓存雪崩">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=什么是缓存雪崩>什么是缓存雪崩？<a href=#什么是缓存雪崩 class=hash-link aria-label="Direct link to 什么是缓存雪崩？" title="Direct link to 什么是缓存雪崩？">​</a></h3>
<p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>
<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>
<div style='background-size:cover;background-repeat:no-repeat;position:relative;background-image:url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAATCAIAAAAmiQu5AAAACXBIWXMAAAsTAAALEwEAmpwYAAABsElEQVR4nG2RPW/TUBiF/UMYGfgRqBIDEqxdGBAra1fUrUNg7EIX6IigLAghBqSIqED5SEmUOKmbOg6pc5NrO76OQ4zvd3xfZBKhCiodHb3SIx0dnddioNyAvXx71OyT3GgGnIH4K4uBPE/kq3ef2wNC4T9MDZegQzKlinOQFxlbYQaijzychpfjhczaPbs/8i7HEoogiakSHCQ1vFTBaFEeJRZ6MRx25ouQg5BQSCgUGAmFAG1RRqbPtj5W7qCn9/OgG5//iB170m1FJ+0EDS3OIu/h7a2NK/UH16n/bdJqTT4derUqOqyFjm0Jw3ni2t/fz8e2XtI/4VrBUoIuw0k+Q2ns+AMXI0RwpnMKYl3QcGtGUzKPzjwH4WEwCzOds3VztmouvF+k2m10yJgaVQAoMAqMLr2wxiy9tb979e7mxuNHx/5Z1KiPjr/gZt3/eoRbDSsQP++92L9288bmk91O5CfuadDrRq6DT+3poFfOkqishwY4i5kRq2S59sJiZmkAMJkypQTAes6Vymon7exDbfTmdVqrsmad//OS+cHz/vb2qFJBOztkb0+CoBfwb4RZ/tAdNXcqAAAAAElFTkSuQmCC")'><svg style=width:100%;height:auto;max-width:100%;margin-bottom:-4px width=365 height=702 /><noscript><img style=width:100%;height:auto;max-width:100%;margin-bottom:-4px;position:absolute;top:0;left:0 src=/assets/ideal-img/redis-cache-avalanche.4cb2a5c.365.png srcset="/assets/ideal-img/redis-cache-avalanche.4cb2a5c.365.png 365w" alt="" width=365 height=702></noscript></div>
<p>举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=有哪些解决办法-2>有哪些解决办法？<a href=#有哪些解决办法-2 class=hash-link aria-label="Direct link to 有哪些解决办法？" title="Direct link to 有哪些解决办法？">​</a></h3>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li><strong>Redis 集群</strong>：采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。Redis Cluster 和 Redis Sentinel 是两种最常用的 Redis 集群实现方案。</li>
<li><strong>多级缓存</strong>：设置多级缓存，例如本地缓存+Redis 缓存的二级缓存组合，当 Redis 缓存出现问题时，还可以从本地缓存中获取到部分数据。</li>
</ol>
<p><strong>针对大量缓存同时失效的情况：</strong></p>
<ol>
<li><strong>设置随机失效时间</strong>（可选）：为缓存设置随机的失效时间，例如在固定过期时间的基础上加上一个随机值，这样可以避免大量缓存同时到期，从而减少缓存雪崩的风险。</li>
<li><strong>提前预热</strong>（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li><strong>持久缓存策略</strong>（看情况）：虽然一般不推荐设置缓存永不过期，但对于某些关键性和变化不频繁的数据，可以考虑这种策略。</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=缓存预热如何实现>缓存预热如何实现？<a href=#缓存预热如何实现 class=hash-link aria-label="Direct link to 缓存预热如何实现？" title="Direct link to 缓存预热如何实现？">​</a></h3>
<p>常见的缓存预热方式有两种：</p>
<ol>
<li>使用<strong>定时任务</strong>，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。</li>
<li>使用<strong>消息队列</strong>，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=缓存雪崩和缓存击穿有什么区别>缓存雪崩和缓存击穿有什么区别？<a href=#缓存雪崩和缓存击穿有什么区别 class=hash-link aria-label="Direct link to 缓存雪崩和缓存击穿有什么区别？" title="Direct link to 缓存雪崩和缓存击穿有什么区别？">​</a></h3>
<p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=如何保证缓存和数据库数据的一致性>如何保证缓存和数据库数据的一致性？<a href=#如何保证缓存和数据库数据的一致性 class=hash-link aria-label="Direct link to 如何保证缓存和数据库数据的一致性？" title="Direct link to 如何保证缓存和数据库数据的一致性？">​</a></h2>
<p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>
<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新数据库，然后直接删除缓存 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说有两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加缓存更新重试机制（常用）</strong>：如果缓存服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。不过，这里更适合引入消息队列实现异步重试，将删除缓存重试的消息投递到消息队列，然后由专门的消费者来重试，直到成功。虽然说多引入了一个消息队列，但其整体带来的收益还是要更高一些。</li>
</ol>
<p>相关文章推荐：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd" target=_blank rel="noopener noreferrer">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=参考资料>参考资料<a href=#参考资料 class=hash-link aria-label="Direct link to 参考资料" title="Direct link to 参考资料">​</a></h2>
<ul>
<li><a href=https://javaguide.cn/database/redis/redis-questions-02.html target=_blank rel="noopener noreferrer">https://javaguide.cn/database/redis/redis-questions-02.html</a></li>
</ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href=/database-and-middleware/redis-sentinel><div class=pagination-nav__sublabel>Previous</div><div class=pagination-nav__label>Redis哨兵机制</div></a><a class="pagination-nav__link pagination-nav__link--next" href=/database-and-middleware/redis-stream><div class=pagination-nav__sublabel>Next</div><div class=pagination-nav__label>Redis Stream简介</div></a></nav><div class=docusaurus-mt-lg></div></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#缓存穿透 class="table-of-contents__link toc-highlight">缓存穿透</a><ul><li><a href=#什么是缓存穿透 class="table-of-contents__link toc-highlight">什么是缓存穿透？</a><li><a href=#有哪些解决办法 class="table-of-contents__link toc-highlight">有哪些解决办法？</a></ul><li><a href=#缓存击穿 class="table-of-contents__link toc-highlight">缓存击穿</a><ul><li><a href=#什么是缓存击穿 class="table-of-contents__link toc-highlight">什么是缓存击穿？</a><li><a href=#有哪些解决办法-1 class="table-of-contents__link toc-highlight">有哪些解决办法？</a><li><a href=#缓存穿透和缓存击穿有什么区别 class="table-of-contents__link toc-highlight">缓存穿透和缓存击穿有什么区别？</a></ul><li><a href=#缓存雪崩 class="table-of-contents__link toc-highlight">缓存雪崩</a><ul><li><a href=#什么是缓存雪崩 class="table-of-contents__link toc-highlight">什么是缓存雪崩？</a><li><a href=#有哪些解决办法-2 class="table-of-contents__link toc-highlight">有哪些解决办法？</a><li><a href=#缓存预热如何实现 class="table-of-contents__link toc-highlight">缓存预热如何实现？</a><li><a href=#缓存雪崩和缓存击穿有什么区别 class="table-of-contents__link toc-highlight">缓存雪崩和缓存击穿有什么区别？</a></ul><li><a href=#如何保证缓存和数据库数据的一致性 class="table-of-contents__link toc-highlight">如何保证缓存和数据库数据的一致性？</a><li><a href=#参考资料 class="table-of-contents__link toc-highlight">参考资料</a></ul></div></div></div></div></main></div></div></div><footer class=footer><div class="container container-fluid"><div class="footer__bottom text--center"><div class=footer__copyright>Copyright 2025 johng.cn</div></div></div></footer></div>