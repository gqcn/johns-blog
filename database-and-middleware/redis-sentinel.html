<!doctype html><html lang=en dir=ltr class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-docs/数据库与中间件/Redis/Redis哨兵机制" data-has-hydrated=false><meta charset=UTF-8><meta name=generator content="Docusaurus v3.6.3"><title data-rh=true>Redis哨兵机制 | John's Blog</title><meta data-rh=true name=viewport content="width=device-width,initial-scale=1.0"><meta data-rh=true name=twitter:card content=summary_large_image><meta data-rh=true property=og:url content=https://johng.cn/database-and-middleware/redis-sentinel><meta data-rh=true property=og:locale content=en><meta data-rh=true name=docusaurus_locale content=en><meta data-rh=true name=docsearch:language content=en><meta data-rh=true name=docusaurus_version content=current><meta data-rh=true name=docusaurus_tag content=docs-default-current><meta data-rh=true name=docsearch:version content=current><meta data-rh=true name=docsearch:docusaurus_tag content=docs-default-current><meta data-rh=true property=og:title content="Redis哨兵机制 | John's Blog"><meta data-rh=true name=description content="详细介绍 Redis Sentinel 哨兵机制的工作原理、配置方法和高可用性保障"><meta data-rh=true property=og:description content="详细介绍 Redis Sentinel 哨兵机制的工作原理、配置方法和高可用性保障"><meta data-rh=true name=keywords content=Redis,哨兵,Sentinel,高可用,主从复制,故障转移,集群管理><link data-rh=true rel=icon href=/img/favicon.ico><link data-rh=true rel=canonical href=https://johng.cn/database-and-middleware/redis-sentinel><link data-rh=true rel=alternate href=https://johng.cn/database-and-middleware/redis-sentinel hreflang=en><link data-rh=true rel=alternate href=https://johng.cn/database-and-middleware/redis-sentinel hreflang=x-default><link data-rh=true rel=preconnect href=https://XGS1CPQERK-dsn.algolia.net crossorigin><link rel=search type=application/opensearchdescription+xml title="John's Blog" href=/opensearch.xml><script src=https://hm.baidu.com/hm.js?6b4ae23dc83ee5efe875b7172af6c7c1 async></script><script src=https://cdn.wwads.cn/js/makemoney.js async></script><link rel=stylesheet href=/assets/css/styles.208c11f9.css><script src=/assets/js/runtime~main.b33a725a.js defer></script><script src=/assets/js/main.f78684f1.js defer></script><body class=navigation-with-keyboard><script>!function(){var t,e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t=null!==e?e:"light",document.documentElement.setAttribute("data-theme",t)}(),function(){try{for(var[t,e]of new URLSearchParams(window.location.search).entries())if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id=__docusaurus><div role=region aria-label="Skip to main content"><a class=skipToContent_fXgn href=#__docusaurus_skipToContent_fallback>Skip to main content</a></div><nav aria-label=Main class="navbar navbar--fixed-top"><div class=navbar__inner><div class=navbar__items><button aria-label="Toggle navigation bar" aria-expanded=false class="navbar__toggle clean-btn" type=button><svg width=30 height=30 viewBox="0 0 30 30" aria-hidden=true><path stroke=currentColor stroke-linecap=round stroke-miterlimit=10 stroke-width=2 d="M4 7h22M4 15h22M4 23h22"/></svg></button><a class=navbar__brand href=/><b class="navbar__title text--truncate">John's Blog</b></a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/ai>AI技术</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/cloud-native>云原生</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/notes>日常笔记</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/programming>开发语言</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/architecture>技术架构</a><a class="navbar__item navbar__link" sidebarid=mainSidebar href=/observability>可观测性</a><a aria-current=page class="navbar__item navbar__link navbar__link--active" sidebarid=mainSidebar href=/database-and-middleware>数据库与中间件</a><a class="navbar__item navbar__link" href=/aboutme>关于我</a></div><div class="navbar__items navbar__items--right"><a href=https://goframe.org/ target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-goframe-link"></a><a href=https://github.com/gqcn target=_blank rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"></a><div class=navbarSearchContainer_Bca1><button type=button class="DocSearch DocSearch-Button" aria-label="Search (Command+K)"><span class=DocSearch-Button-Container><svg width=20 height=20 class=DocSearch-Search-Icon viewBox="0 0 20 20" aria-hidden=true><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke=currentColor fill=none fill-rule=evenodd stroke-linecap=round stroke-linejoin=round /></svg><span class=DocSearch-Button-Placeholder>Search</span></span><span class=DocSearch-Button-Keys></span></button></div></div></div><div role=presentation class=navbar-sidebar__backdrop></div></nav><div id=__docusaurus_skipToContent_fallback class="main-wrapper mainWrapper_z2l0"><div class=docsWrapper_hBAB><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type=button></button><div class=docRoot_UBD9><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class=sidebarViewport_aRkj><div class=sidebar_njMd><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/ai>AI技术</a><button aria-label="Expand sidebar category 'AI技术'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/cloud-native>云原生</a><button aria-label="Expand sidebar category '云原生'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/notes>日常笔记</a><button aria-label="Expand sidebar category '日常笔记'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/programming>开发语言</a><button aria-label="Expand sidebar category '开发语言'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/architecture>技术架构</a><button aria-label="Expand sidebar category '技术架构'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/management>技术管理</a><button aria-label="Expand sidebar category '技术管理'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/observability>可观测性</a><button aria-label="Expand sidebar category '可观测性'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist menu__link--active" href=/database-and-middleware>数据库与中间件</a><button aria-label="Collapse sidebar category '数据库与中间件'" aria-expanded=true type=button class="clean-btn menu__caret"></button></div><ul style=display:block;overflow:visible;height:auto class=menu__list><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" tabindex=0 href=/database-and-middleware/mysql>MySQL</a><button aria-label="Expand sidebar category 'MySQL'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist menu__link--active" tabindex=0 href=/database-and-middleware/redis>Redis</a><button aria-label="Collapse sidebar category 'Redis'" aria-expanded=true type=button class="clean-btn menu__caret"></button></div><ul style=display:block;overflow:visible;height:auto class=menu__list><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/database-and-middleware/redis-skiplist-sorted-set>Redis 为什么用跳表实现有序集合</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current=page tabindex=0 href=/database-and-middleware/redis-sentinel>Redis哨兵机制</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/database-and-middleware/redis-cache-issues>Redis缓存常见问题</a><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class=menu__link tabindex=0 href=/database-and-middleware/redis-stream>Redis Stream简介</a></ul><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" tabindex=0 href=/database-and-middleware/etcd>Etcd</a><button aria-label="Expand sidebar category 'Etcd'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class=menu__link tabindex=0 href=/database-and-middleware/database-normalization>数据库三大范式与反三范式</a></ul><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class=menu__list-item-collapsible><a class="menu__link menu__link--sublist" href=/operating-systems-and-networks>操作系统和网络</a><button aria-label="Expand sidebar category '操作系统和网络'" aria-expanded=false type=button class="clean-btn menu__caret"></button></div></ul></nav></div></div></aside><main class=docMainContainer_TBSr><div class="container padding-top--md padding-bottom--lg"><div class=row><div class="col docItemCol_VOVn"><div class=docItemContainer_Djhp><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label=Breadcrumbs><ul class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li class=breadcrumbs__item><a aria-label="Home page" class=breadcrumbs__link href=/><svg viewBox="0 0 24 24" class=breadcrumbHomeIcon_YNFT><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill=currentColor /></svg></a><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class=breadcrumbs__item><a class=breadcrumbs__link itemprop=item href=/database-and-middleware><span itemprop=name>数据库与中间件</span></a><meta itemprop=position content=1><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class=breadcrumbs__item><a class=breadcrumbs__link itemprop=item href=/database-and-middleware/redis><span itemprop=name>Redis</span></a><meta itemprop=position content=2><li itemscope itemprop=itemListElement itemtype=https://schema.org/ListItem class="breadcrumbs__item breadcrumbs__item--active"><span class=breadcrumbs__link itemprop=name>Redis哨兵机制</span><meta itemprop=position content=3></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type=button class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><h2 class="anchor anchorWithStickyNavbar_LWe7" id=为什么要有哨兵机制>为什么要有哨兵机制？<a href=#为什么要有哨兵机制 class=hash-link aria-label="Direct link to 为什么要有哨兵机制？" title="Direct link to 为什么要有哨兵机制？">​</a></h2>
<p>在 Redis 的主从架构中，由于主从模式是读写分离的，如果主节点（master）挂了，那么将没有主节点来服务客户端的写操作请求，也没有主节点给从节点（slave）进行数据同步了。</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-45-59-a75bb2c2ad9edcdba56e3ab72c3988de.png width=1480 height=716 class=img_ev3q></p>
<p>这时如果要恢复服务的话，需要人工介入，选择一个「从节点」切换为「主节点」，然后让其他从节点指向新的主节点，同时还需要通知上游那些连接 Redis 主节点的客户端，将其配置中的主节点 IP 地址更新为「新主节点」的 IP 地址。</p>
<p>这样也不太“智能”了，要是有一个节点能监控「主节点」的状态，当发现主节点挂了，它自动将一个「从节点」切换为「主节点」的话，那么可以节省我们很多事情啊！</p>
<p>Redis 在 2.8 版本以后提供的<strong>哨兵（<em>Sentinel</em>）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=哨兵机制是如何工作的>哨兵机制是如何工作的？<a href=#哨兵机制是如何工作的 class=hash-link aria-label="Direct link to 哨兵机制是如何工作的？" title="Direct link to 哨兵机制是如何工作的？">​</a></h2>
<p>哨兵其实是一个运行在特殊模式下的 Redis 进程，所以它也是一个节点。从“哨兵”这个名字也可以看得出来，它相当于是“观察者节点”，观察的对象是主从节点。</p>
<p>当然，它不仅仅是观察那么简单，在它观察到有异常的状况下，会做出一些“动作”，来修复异常状态。</p>
<p>哨兵节点主要负责三件事情：<strong>监控、选主、通知</strong>。</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-46-27-a16d967576c2904cc1d773e4d171594d.png width=1480 height=528 class=img_ev3q></p>
<p>所以，我们重点要学习这三件事情：</p>
<ul>
<li>哨兵节点是如何监控节点的？又是如何判断主节点是否真的故障了？</li>
<li>根据什么规则选择一个从节点切换为主节点？</li>
<li>怎么把新主节点的相关信息通知给从节点和客户端呢？</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=如何判断主节点真的故障了>如何判断主节点真的故障了？<a href=#如何判断主节点真的故障了 class=hash-link aria-label="Direct link to 如何判断主节点真的故障了？" title="Direct link to 如何判断主节点真的故障了？">​</a></h2>
<p>哨兵会每隔 1 秒给所有主从节点发送 PING 命令，当主从节点收到 PING 命令后，会发送一个响应命令给哨兵，这样就可以判断它们是否在正常运行。</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-46-47-5b9c3b56ea661711186b1bc7ab81bc41.png width=1480 height=844 class=img_ev3q></p>
<p>如果主节点或者从节点没有在规定的时间内响应哨兵的 PING 命令，哨兵就会将它们标记为「<strong>主观下线</strong>」。这个「规定的时间」是配置项 <code>down-after-milliseconds</code> 参数设定的，单位是毫秒。</p>
<blockquote>
<p>主观下线？难道还有客观下线？</p>
</blockquote>
<p>是的没错，客观下线只适用于主节点。</p>
<p>之所以针对「主节点」设计「主观下线」和「客观下线」两个状态，是因为有可能「主节点」其实并没有故障，可能只是因为主节点的系统压力比较大或者网络发送了拥塞，导致主节点没有在规定时间内响应哨兵的 PING 命令。</p>
<p>所以，为了减少误判的情况，哨兵在部署的时候不会只部署一个节点，而是用多个节点部署成<strong>哨兵集群</strong>（<em>最少需要三台机器来部署哨兵集群</em>），<strong>通过多个哨兵节点一起判断，就可以就可以避免单个哨兵因为自身网络状况不好，而误判主节点下线的情况</strong>。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<p>具体是怎么判定主节点为「客观下线」的呢？</p>
<p>当一个哨兵判断主节点为「主观下线」后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-47-7-6088e1ac6960df01b217c10ad249de30.png width=1480 height=952 class=img_ev3q></p>
<p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p>
<p>例如，现在有 3 个哨兵，quorum 配置的是 2，那么一个哨兵需要 2 张赞成票，就可以标记主节点为“客观下线”了。这 2 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。</p>
<p>PS：quorum 的值一般设置为哨兵个数的二分之一加 1，例如 3 个哨兵就设置 2。</p>
<p>哨兵判断完主节点客观下线后，哨兵就要开始在多个「从节点」中，选出一个从节点来做新主节点。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=由哪个哨兵进行主从故障转移>由哪个哨兵进行主从故障转移？<a href=#由哪个哨兵进行主从故障转移 class=hash-link aria-label="Direct link to 由哪个哨兵进行主从故障转移？" title="Direct link to 由哪个哨兵进行主从故障转移？">​</a></h2>
<p>前面说过，为了更加“客观”的判断主节点故障了，一般不会只由单个哨兵的检测结果来判断，而是多个哨兵一起判断，这样可以减少误判概率，所以<strong>哨兵是以哨兵集群的方式存在的</strong>。</p>
<p>问题来了，由哨兵集群中的哪个节点进行主从故障转移呢？</p>
<p>所以这时候，还需要在哨兵集群中选出一个 leader，让 leader 来执行主从切换。</p>
<p>选举 leader 的过程其实是一个投票的过程，在投票开始前，肯定得有个「候选者」。</p>
<blockquote>
<p>那谁来作为候选者呢？</p>
</blockquote>
<p>哪个哨兵节点判断主节点为「客观下线」，这个哨兵节点就是候选者，所谓的候选者就是想当 Leader 的哨兵。</p>
<p>举个例子，假设有三个哨兵。当哨兵 B 先判断到主节点「主观下线后」，就会给其他实例发送 is-master-down-by-addr 命令。接着，其他哨兵会根据自己和主节点的网络连接情况，做出赞成投票或者拒绝投票的响应。</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-47-26-f1712ad509aa09b8ef967f960797cc3b.png width=1480 height=1302 class=img_ev3q></p>
<p>当哨兵 B 收到赞成票数达到哨兵配置文件中的 quorum 配置项设定的值后，就会将主节点标记为「客观下线」，此时的哨兵 B 就是一个 Leader 候选者。</p>
<blockquote>
<p>候选者如何选举成为 Leader？</p>
</blockquote>
<p>候选者会向其他哨兵发送命令，表明希望成为 Leader 来执行主从切换，并让所有其他哨兵对它进行投票。</p>
<p>每个哨兵只有一次投票机会，如果用完后就不能参与投票了，可以投给自己或投给别人，但是只有候选者才能把票投给自己。</p>
<p>那么在投票过程中，任何一个「候选者」，要满足两个条件：</p>
<ul>
<li>第一，拿到半数以上的赞成票；</li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li>
</ul>
<p>举个例子，假设哨兵节点有 3 个，quorum 设置为 2，那么任何一个想成为 Leader 的哨兵只要拿到 2 张赞成票，就可以选举成功了。如果没有满足条件，就需要重新进行选举。</p>
<p>这时候有的同学就会问了，如果某个时间点，刚好有两个哨兵节点判断到主节点为客观下线，那这时不就有两个候选者了？这时该如何决定谁是 Leader 呢？</p>
<p>每位候选者都会先给自己投一票，然后向其他哨兵发起投票请求。如果投票者先收到「候选者 A」的投票请求，就会先投票给它，如果投票者用完投票机会后，收到「候选者 B」的投票请求后，就会拒绝投票。这时，候选者 A 先满足了上面的那两个条件，所以「候选者 A」就会被选举为 Leader。</p>
<blockquote>
<p>为什么哨兵节点至少要有 3 个？</p>
</blockquote>
<p>如果哨兵集群中只有 2 个哨兵节点，此时如果一个哨兵想要成功成为 Leader，必须获得 2 票，而不是 1 票。</p>
<p>所以，如果哨兵集群中有个哨兵挂掉了，那么就只剩一个哨兵了，如果这个哨兵想要成为 Leader，这时票数就没办法达到 2 票，就无法成功成为 Leader，这时是无法进行主从节点切换的。</p>
<p>因此，通常我们至少会配置 3 个哨兵节点。这时，如果哨兵集群中有个哨兵挂掉了，那么还剩下两个哨兵，如果这个哨兵想要成为 Leader，这时还是有机会达到 2 票的，所以还是可以选举成功的，不会导致无法进行主从节点切换。</p>
<p>当然，你要问，如果 3 个哨兵节点，挂了 2 个怎么办？这个时候得人为介入了，或者增加多一点哨兵节点。</p>
<p>再说一个问题，Redis 1 主 4 从，5 个哨兵，quorum 设置为 3，如果 2 个哨兵故障，当主节点宕机时，哨兵能否判断主节点“客观下线”？主从能否自动切换？</p>
<ul>
<li>
<p><strong>哨兵集群可以判定主节点“客观下线”</strong>。哨兵集群还剩下 3 个哨兵，当一个哨兵判断主节点“主观下线”后，询问另外 2 个哨兵后，有可能能拿到 3 张赞同票，这时就达到了 quorum 的值，因此，哨兵集群可以判定主节点为“客观下线”。</p>
</li>
<li>
<p><strong>哨兵集群可以完成主从切换</strong>。当有个哨兵标记主节点为「客观下线」后，就会进行选举 Leader 的过程，因为此时哨兵集群还剩下 3 个哨兵，那么还是可以拿到半数以上（5/2+1=3）的票，而且也达到了 quorum 值，满足了选举 Leader 的两个条件，所以就能选举成功，因此哨兵集群可以完成主从切换。</p>
</li>
</ul>
<p>如果 quorum 设置为 2，并且如果有 3 个哨兵故障的话。此时哨兵集群还是可以判定主节点为“客观下线”，但是哨兵不能完成主从切换了，大家可以自己推演下。</p>
<p>如果 quorum 设置为 3，并且如果有 3 个哨兵故障的话，哨兵集群即不能判定主节点为“客观下线”，也不能完成主从切换了。</p>
<p>可以看到，quorum 为 2 的时候，并且如果有 3 个哨兵故障的话，虽然可以判定主节点为“客观下线”，但是不能完成主从切换，这样感觉「判定主节点为客观下线」这件事情白做了一样，既然这样，还不如不要做，quorum 为 3 的时候，就可以避免这种无用功。</p>
<p>所以，<strong>quorum 的值建议设置为哨兵个数的二分之一加 1</strong>，例如 3 个哨兵就设置 2，5 个哨兵设置为 3，而且<strong>哨兵节点的数量应该是奇数</strong>。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=主从故障转移的过程是怎样的>主从故障转移的过程是怎样的？<a href=#主从故障转移的过程是怎样的 class=hash-link aria-label="Direct link to 主从故障转移的过程是怎样的？" title="Direct link to 主从故障转移的过程是怎样的？">​</a></h2>
<p>在哨兵集群中通过投票的方式，选举出了哨兵 leader 后，就可以进行主从故障转移的过程了，如下图：</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-47-48-a89dd54dca3d5612cac6dd797ac12419.png width=1480 height=414 class=img_ev3q></p>
<p>主从故障转移操作包含以下四个步骤：</p>
<ul>
<li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点。</li>
<li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li>
<li>第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；</li>
<li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=步骤一选出新主节点>步骤一：选出新主节点<a href=#步骤一选出新主节点 class=hash-link aria-label="Direct link to 步骤一：选出新主节点" title="Direct link to 步骤一：选出新主节点">​</a></h3>
<p>故障转移操作第一步要做的就是在已下线主节点属下的所有「从节点」中，挑选出一个状态良好、数据完整的从节点，然后向这个「从节点」发送 SLAVEOF no one 命令，将这个「从节点」转换为「主节点」。</p>
<p>那么多「从节点」，到底选择哪个从节点作为新主节点的？</p>
<p>随机的方式好吗？随机的方式，实现起来很简单，但是如果选到一个网络状态不好的从节点作为新主节点，那么可能在将来不久又要做一次主从故障迁移。</p>
<p>所以，我们首先要把网络状态不好的从节点给过滤掉。首先把已经下线的从节点过滤掉，然后把以往网络连接状态不好的从节点也给过滤掉。</p>
<p>怎么判断从节点之前的网络连接状态不好呢？</p>
<p>Redis 有个叫 down-after-milliseconds * 10 配置项，其 down-after-milliseconds 是主从节点断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从节点的网络状况不好，不适合作为新主节点。</p>
<p>至此，我们就把网络状态不好的从节点过滤掉了，接下来要对所有从节点进行三轮考察：<strong>优先级、复制进度、ID 号</strong>。在进行每一轮考察的时候，哪个从节点优先胜出，就选择其作为新主节点。</p>
<ul>
<li>第一轮考察：哨兵首先会根据从节点的优先级来进行排序，优先级越小排名越靠前，</li>
<li>第二轮考察：如果优先级相同，则查看复制的下标，哪个从「主节点」接收的复制数据多，哪个就靠前。</li>
<li>第三轮考察：如果优先级和下标都相同，就选择从节点 ID 较小的那个。</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=第一轮考察优先级最高的从节点胜出>第一轮考察：优先级最高的从节点胜出<a href=#第一轮考察优先级最高的从节点胜出 class=hash-link aria-label="Direct link to 第一轮考察：优先级最高的从节点胜出" title="Direct link to 第一轮考察：优先级最高的从节点胜出">​</a></h4>
<p>Redis 有个叫 slave-priority 配置项，可以给从节点设置优先级。</p>
<p>每一台从节点的服务器配置不一定是相同的，我们可以根据服务器性能配置来设置从节点的优先级。</p>
<p>比如，如果「A 从节点」的物理内存是所有从节点中最大的，那么我们可以把「A 从节点」的优先级设置成最高。这样当哨兵进行第一轮考虑的时候，优先级最高的 A 从节点就会优先胜出，于是就会成为新主节点。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=第二轮考察复制进度最靠前的从节点胜出>第二轮考察：复制进度最靠前的从节点胜出<a href=#第二轮考察复制进度最靠前的从节点胜出 class=hash-link aria-label="Direct link to 第二轮考察：复制进度最靠前的从节点胜出" title="Direct link to 第二轮考察：复制进度最靠前的从节点胜出">​</a></h4>
<p>如果在第一轮考察中，发现优先级最高的从节点有两个，那么就会进行第二轮考察，比较两个从节点哪个复制进度。</p>
<p>什么是复制进度？主从架构中，主节点会将写操作同步给从节点，在这个过程中，主节点会用 master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置（如下图中的「主服务器已经写入的数据」的位置），而从节点会用 slave_repl_offset 这个值记录当前的复制进度（如下图中的「从服务器要读的位置」的位置）。</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-48-5-16ed37122ef36767a442273f01e5ef29.png width=1480 height=522 class=img_ev3q></p>
<p>如果某个从节点的 slave_repl_offset 最接近 master_repl_offset，说明它的复制进度是最靠前的，于是就可以将它选为新主节点。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id=第三轮考察id-号小的从节点胜出>第三轮考察：ID 号小的从节点胜出<a href=#第三轮考察id-号小的从节点胜出 class=hash-link aria-label="Direct link to 第三轮考察：ID 号小的从节点胜出" title="Direct link to 第三轮考察：ID 号小的从节点胜出">​</a></h4>
<p>如果在第二轮考察中，发现有两个从节点优先级和复制进度都是一样的，那么就会进行第三轮考察，比较两个从节点的 ID 号，ID 号小的从节点胜出。</p>
<p>什么是 ID 号？每个从节点都有一个编号，这个编号就是 ID 号，是用来唯一标识从节点的。</p>
<p>到这里，选主的事情终于结束了。简单给大家总结下：</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-48-22-2d27b0a97def992acb8d93c05ba60672.png width=1480 height=1730 class=img_ev3q></p>
<p>在选举出从节点后，哨兵 leader 向被选中的从节点发送 <code>SLAVEOF no one</code> 命令，让这个从节点解除从节点的身份，将其变为新主节点。</p>
<p>如下图，哨兵 leader 向被选中的从节点 server2 发送 <code>SLAVEOF no one</code> 命令，将该从节点升级为新主节点。</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-48-46-7a82727c1ac81edc417306986c04415d.png width=1480 height=922 class=img_ev3q></p>
<p>在发送 <code>SLAVEOF no one</code> 命令之后，哨兵 leader 会以每秒一次的频率向被升级的从节点发送 <code>INFO</code> 命令（没进行故障转移之前，<code>INFO</code> 命令的频率是每十秒一次），并观察命令回复中的角色信息，当被升级节点的角色信息从原来的 slave 变为 master 时，哨兵 leader 就知道被选中的从节点已经顺利升级为主节点了。</p>
<p>如下图，选中的从节点 server2 升级成了新主节点：</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-49-6-3cba78ed74e3cd31fab140f49d4f5b71.png width=1480 height=1062 class=img_ev3q></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=步骤二将从节点指向新主节点>步骤二：将从节点指向新主节点<a href=#步骤二将从节点指向新主节点 class=hash-link aria-label="Direct link to 步骤二：将从节点指向新主节点" title="Direct link to 步骤二：将从节点指向新主节点">​</a></h3>
<p>当新主节点出现之后，哨兵 leader 下一步要做的就是，让已下线主节点属下的所有「从节点」指向「新主节点」，这一动作可以通过向「从节点」发送 <code>SLAVEOF</code> 命令来实现。</p>
<p>如下图，哨兵 leader 向所有从节点（server3 和 server4）发送 <code>SLAVEOF</code> ，让它们成为新主节点的从节点。</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-49-58-4a9cc235deed778b066c185314ca78f5.png width=1480 height=798 class=img_ev3q></p>
<p>所有从节点指向新主节点后的拓扑图如下：</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-50-12-655834d9186a17fe6800ea752cbd94b2.png width=1480 height=1132 class=img_ev3q></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=步骤三通知客户的主节点已更换>步骤三：通知客户的主节点已更换<a href=#步骤三通知客户的主节点已更换 class=hash-link aria-label="Direct link to 步骤三：通知客户的主节点已更换" title="Direct link to 步骤三：通知客户的主节点已更换">​</a></h3>
<p>经过前面一系列的操作后，哨兵集群终于完成主从切换的工作，那么新主节点的信息要如何通知给客户端呢？</p>
<p>这主要<strong>通过 Redis 的发布者/订阅者机制来实现</strong>的。每个哨兵节点提供发布者/订阅者机制，客户端可以从哨兵订阅消息。</p>
<p>哨兵提供的消息订阅频道有很多，不同频道包含了主从节点切换过程中的不同关键事件，几个常见的事件如下：</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-50-38-76b099cd97bb422bdee4201fa11fdd4c.png width=1480 height=900 class=img_ev3q></p>
<p>客户端和哨兵建立连接后，客户端会订阅哨兵提供的频道。<strong>主从切换完成后，哨兵就会向 <code>+switch-master</code> 频道发布新主节点的 IP 地址和端口的消息，这个时候客户端就可以收到这条信息，然后用这里面的新主节点的 IP 地址和端口进行通信了</strong>。</p>
<p>通过发布者/订阅者机制机制，有了这些事件通知，客户端不仅可以在主从切换后得到新主节点的连接信息，还可以监控到主从节点切换过程中发生的各个重要事件。这样，客户端就可以知道主从切换进行到哪一步了，有助于了解切换进度。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id=步骤四将旧主节点变为从节点>步骤四：将旧主节点变为从节点<a href=#步骤四将旧主节点变为从节点 class=hash-link aria-label="Direct link to 步骤四：将旧主节点变为从节点" title="Direct link to 步骤四：将旧主节点变为从节点">​</a></h3>
<p>故障转移操作最后要做的是，继续监视旧主节点，当旧主节点重新上线时，哨兵集群就会向它发送 <code>SLAVEOF</code> 命令，让它成为新主节点的从节点，如下图：</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-50-57-0c989d9fa707f12a40ff9a32aaa01727.png width=1480 height=1190 class=img_ev3q></p>
<p>至此，整个主从节点的故障转移的工作结束。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=哨兵集群是如何组成的>哨兵集群是如何组成的？<a href=#哨��兵集群是如何组成的 class=hash-link aria-label="Direct link to 哨兵集群是如何组成的？" title="Direct link to 哨兵集群是如何组成的？">​</a></h2>
<p>前面提到了 Redis 的发布者/订阅者机制，那就不得不提一下哨兵集群的组成方式，因为它也用到了这个技术。</p>
<p>在我第一次搭建哨兵集群的时候，当时觉得很诧异。因为在配置哨兵的信息时，竟然只需要填下面这几个参数，设置主节点名字、主节点的 IP 地址和端口号以及 quorum 值。</p>
<div class="language-bash codeBlockContainer_Ckt0 theme-code-block" style=--prism-color:#f8f8f2;--prism-background-color:#272822><div class=codeBlockContent_biex><pre tabindex=0 class="prism-code language-bash codeBlock_bY9V thin-scrollbar" style=color:#f8f8f2;background-color:#272822><code class=codeBlockLines_e6Vv><span class=token-line style=color:#f8f8f2><span class="token plain">sentinel monitor </span><span class="token operator" style=color:#66d9ef>&lt;</span><span class="token plain">master-name</span><span class="token operator" style=color:#66d9ef>></span><span class="token plain"> </span><span class="token operator" style=color:#66d9ef>&lt;</span><span class="token plain">ip</span><span class="token operator" style=color:#66d9ef>></span><span class="token plain"> </span><span class="token operator" style=color:#66d9ef>&lt;</span><span class="token plain">redis-port</span><span class="token operator" style=color:#66d9ef>></span><span class="token plain"> </span><span class="token operator" style=color:#66d9ef>&lt;</span><span class="token plain">quorum</span><span class="token operator" style=color:#66d9ef>></span><br></span></code></pre><div class=buttonGroup__atx><button type=button aria-label="Copy code to clipboard" title=Copy class=clean-btn><span class=copyButtonIcons_eSgA aria-hidden=true><svg viewBox="0 0 24 24" class=copyButtonIcon_y97N><path fill=currentColor d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"/></svg><svg viewBox="0 0 24 24" class=copyButtonSuccessIcon_LjdS><path fill=currentColor d=M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z /></svg></span></button></div></div></div>
<p>不需要填其他哨兵节点的信息，我就好奇它们是如何感知对方的，又是如何组成哨兵集群的？</p>
<p>后面才了解到，<strong>哨兵节点之间是通过 Redis 的发布者/订阅者机制来相互发现的</strong>。</p>
<p>在主从集群中，主节点上有一个名为<code>__sentinel__:hello</code>的频道，不同哨兵就是通过它来相互发现，实现互相通信的。</p>
<p>在下图中，哨兵 A 把自己的 IP 地址和端口的信息发布到<code>__sentinel__:hello</code> 频道上，哨兵 B 和 C 订阅了该频道。那么此时，哨兵 B 和 C 就可以从这个频道直接获取哨兵 A 的 IP 地址和端口号。然后，哨兵 B、C 可以和哨兵 A 建立网络连接。</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-51-20-2420dca366a2bfd1cade17527513794b.png width=1480 height=1320 class=img_ev3q></p>
<p>通过这个方式，哨兵 B 和 C 也可以建立网络连接，这样一来，哨兵集群就形成了。</p>
<blockquote>
<p>哨兵集群会对「从节点」的运行状态进行监控，那哨兵集群如何知道「从节点」的信息？</p>
</blockquote>
<p>主节点知道所有「从节点」的信息，所以哨兵会每 10 秒一次的频率向主节点发送 INFO 命令来获取所有「从节点」的信息。</p>
<p>如下图所示，哨兵 B 给主节点发送 INFO 命令，主节点接受到这个命令后，就会把从节点列表返回给哨兵。接着，哨兵就可以根据从节点列表中的连接信息，和每个从节点建立连接，并在这个连接上持续地对从节点进行监控。哨兵 A 和 C 可以通过相同的方法和从节点建立连接。</p>
<p><img decoding=async loading=lazy src=/assets/images/image-2024-9-6_15-51-41-58a445217bcaedd4c1e39eb5153f9be1.png width=1480 height=906 class=img_ev3q></p>
<p>正是通过 Redis 的发布者/订阅者机制，哨兵之间可以相互感知，然后组成集群，同时，哨兵又通过 INFO 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=总结>总结<a href=#总结 class=hash-link aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p>Redis 在 2.8 版本以后提供的<strong>哨兵（<em>Sentinel</em>）机制</strong>，它的作用是实现<strong>主从节点故障转移</strong>。它会监测主节点是否存活，如果发现主节点挂了，它就会选举一个从节点切换为主节点，并且把新主节点的相关信息通知给从节点和客户端。</p>
<p>哨兵一般是以集群的方式部署，至少需要 3 个哨兵节点，哨兵集群主要负责三件事情：<strong>监控、选主、通知</strong>。</p>
<p>哨兵节点通过 Redis 的发布者/订阅者机制，哨兵之间可以相互感知，相互连接，然后组成哨兵集群，同时哨兵又通过 INFO 命令，在主节点里获得了所有从节点连接信息，于是就能和从节点建立连接，并进行监控了。</p>
<p><em>1、第一轮投票：判断主节点下线</em></p>
<p>当哨兵集群中的某个哨兵判定主节点下线（主观下线）后，就会向其他哨兵发起命令，其他哨兵收到这个命令后，就会根据自身和主节点的网络状况，做出赞成投票或者拒绝投票的响应。</p>
<p>当这个哨兵的赞同票数达到哨兵配置文件中的 quorum 配置项设定的值后，这时主节点就会被该哨兵标记为「客观下线」。</p>
<p><em>2、第二轮投票：选出哨兵 leader</em></p>
<p>某个哨兵判定主节点客观下线后，该哨兵就会发起投票，告诉其他哨兵，它想成为 leader，想成为 leader 的哨兵节点，要满足两个条件：</p>
<ul>
<li>第一，拿到半数以上的赞成票；</li>
<li>第二，拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li>
</ul>
<p><em>3、由哨兵 leader 进行主从故障转移</em></p>
<p>选举出了哨兵 leader 后，就可以进行主从故障转移的过程了。该操作包含以下四个步骤：</p>
<ul>
<li>第一步：在已下线主节点（旧主节点）属下的所有「从节点」里面，挑选出一个从节点，并将其转换为主节点，选择的规则：<!-- -->
<ul>
<li>过滤掉已经离线的从节点；</li>
<li>过滤掉历史网络连接状态不好的从节点；</li>
<li>将剩下的从节点，进行三轮考察：优先级、复制进度、ID 号。在每一轮考察过程中，如果找到了一个胜出的从节点，就将其作为新主节点。</li>
</ul>
</li>
<li>第二步：让已下线主节点属下的所有「从节点」修改复制目标，修改为复制「新主节点」；</li>
<li>第三步：将新主节点的 IP 地址和信息，通过「发布者/订阅者机制」通知给客户端；</li>
<li>第四步：继续监视旧主节点，当这个旧主节点重新上线时，将它设置为新主节点的从节点；</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id=参考资料>参考资料<a href=#参考资料 class=hash-link aria-label="Direct link to 参考资料" title="Direct link to 参考资料">​</a></h2>
<ul>
<li><a href=https://www.xiaolincoding.com/redis/cluster/sentinel.html target=_blank rel="noopener noreferrer">https://www.xiaolincoding.com/redis/cluster/sentinel.html</a></li>
<li></li>
</ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href=/database-and-middleware/redis-skiplist-sorted-set><div class=pagination-nav__sublabel>Previous</div><div class=pagination-nav__label>Redis 为什么用跳表实现有序集合</div></a><a class="pagination-nav__link pagination-nav__link--next" href=/database-and-middleware/redis-cache-issues><div class=pagination-nav__sublabel>Next</div><div class=pagination-nav__label>Redis缓存常见问题</div></a></nav><div class=docusaurus-mt-lg></div></div></div><div class="col col--3"><div class=tocContainer_PXzm><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href=#为什么要有哨兵机制 class="table-of-contents__link toc-highlight">为什么要有哨兵机制？</a><li><a href=#哨兵机制是如何工作的 class="table-of-contents__link toc-highlight">哨兵机制是如何工作的？</a><li><a href=#如何判断主节点真的故障了 class="table-of-contents__link toc-highlight">如何判断主节点真的故障了？</a><li><a href=#由哪个哨兵进行主从故障转移 class="table-of-contents__link toc-highlight">由哪个哨兵进行主从故障转移？</a><li><a href=#主从故障转移的过程是怎样的 class="table-of-contents__link toc-highlight">主从故障转移的过程是怎样的？</a><ul><li><a href=#步骤一选出新主节点 class="table-of-contents__link toc-highlight">步骤一：选出新主节点</a><li><a href=#步骤二将从节点指向新主节点 class="table-of-contents__link toc-highlight">步骤二：将从节点指向新主节点</a><li><a href=#步骤三通知客户的主节点已更换 class="table-of-contents__link toc-highlight">步骤三：通知客户的主节点已更换</a><li><a href=#步骤四将旧主节点变为从节点 class="table-of-contents__link toc-highlight">步骤四：将旧主节点变为从节点</a></ul><li><a href=#哨兵集群是如何组成的 class="table-of-contents__link toc-highlight">哨兵集群是如何组成的？</a><li><a href=#总结 class="table-of-contents__link toc-highlight">总结</a><li><a href=#参考��资料 class="table-of-contents__link toc-highlight">参考资料</a></ul></div><div class=tocAdBanner_imxD></div></div></div></div></div></main></div></div></div><footer class=footer><div class="container container-fluid"><div class="footer__bottom text--center"><div class=footer__copyright>Copyright 2025 johng.cn</div></div></div></footer></div>